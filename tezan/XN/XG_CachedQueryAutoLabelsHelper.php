<?php
/*
 *	Helper class to handle automatic labels (autolabels). Used as a part of XG_CachedQuery.
 *	Handles parsing, storing and invalidating automatic labels.
 *
 *	AUTOLABELS SYNTAX
 *	1. Type labels:
 *		Invalidated when any object of this type changes
 *			TYPE:create				Invalidated when a new object of this type is created
 *			TYPE:delete				Invalidated when any object of this type is deleted
 *	-------	TYPE:update ----------- Invalidated when any object of this type is updated -------------- [not supported]
 *		Example:
 *			"Comment:create"
 *
 *	2. Property labels:
 *		Invalidated when the object is updated and this property changes or the object is created and the initial property value is not NULL:
 *			TYPE.PROP				Invalidated when this property changes
 *			TYPE.PROP=VALUE			When this property changes, 2 labels are invalidated: with original value and with the new value.
 *									Can be useful when possible property values are clusterized, like my.approved=Y|N or contributorName=screenName,
 *									in this case invalidating one group doesn't affect other groups.
 *			TYPE.PROP1[L]=VALUE		The same, but value is lowercased. Can be useful when the value case is not significant
 *		Example:
 *			"Comment.my.attachedTo"
 *			"Topic.my.approved=N"
 *			"User.title[L]=$screenName"
 *
 *  3. Composite property labels:
 *  	When even-finer-grained targeting is required, labels can be concatenated:
 *  		array(PROP_LABEL1,...)	This label invalidated when any included property changes, but the whole chain of properties
 *  								is invalidated. When autoLabelPrefix() method is used, all simple labels become composite and
 *  								are concatenated this the specified prefix.
 *		Example:
 *			array("Comment.my.attachedTo=$id","Comment.my.approved=N")
 *				If you have this invalidation label attached to your query, it will be invalidated only when
 *				a new comment attached to this ID is created and it has my.approved value of "N".
 *
 *	4. Automatic label suppressing:
 *		If you have autoLabels() turned on for your query, all attributes used in the query are added as an automatic labels.
 *		If you want to exclude one or more attributes you can use the following syntax:
 *			-TYPE.PROP				Example: "-Topic.my.commentCount"
 *		This attribute still can be added to the list of invalidation labels, but only as a part of composite label.
 *
 *	LABELS TRACKING
 * 	It doesn't make sense to invalidate all possible labels when an object changes. So instead of this, this class tracks all properties
 * 	used in single and composite labels and invalidates only them. When any property hasn't been used in labels for a while, class stops
 * 	tracking it. If the tracking data becomes corrupted, it's enough to clear application cache, and it recovers itself as new queries
 * 	are issued.
 *
 */

class XG_CachedQueryAutoLabelsHelper {
	/** Label format constants */
	const NO_VALUE = 0;				// TYPE.PROP
	const VALUE = 1;				// TYPE.PROP=VALUE
	const LC_VALUE = 2;				// TYPE.PROP[L]=VALUE

    /**
	 * 	The number of days label hasn't been used, after that we can stop invalidating it
	 *  @var    int
     */
	static protected $expirePeriod = 7;

    /**
	 * 	Config identifier for the used autolabels info
     *  @var    string
     */
	static protected $configModuleName = 'xg-cached-query';

    /**
	 * 	Prefix for all XN_Cache labels generated by this class
     *  @var    string
     */
	static protected $cachePrefix = 'xg-autolabel:';

    /**
	 * 	Whether class was inited
     *  @var	bool
     */
	static protected $inited = false;

    /**
	 * 	Original value of updatedDate for the config
     *  @var    string
     */
	static protected $origUpdatedDate;

    /**
     * 	Original value of configuration data
     *  @var    string
     */
	static protected $origConfig;

    /**
     * 	Unserialized configuration.
     *  Format:
	 *  	type: {
	 *  		create: DATE,								type uses ":create"
	 *  		delete: DATE,                               type uses ":delete"
	 *  		update: DATE,
	 *  		props: {     								Information about individual properies
	 *  			name: {
	 *  				noValue: DATE,						property is used w/o value
	 *  				value: DATE,						property is used w/value
	 *  				lcValue: DATE,						property is used w/lowercased value
	 *  				inComposites: DATE,					property is used as a part of composite label
	 *  			},
	 *  		},
	 *  		composites: {								Information about composite labels
	 *  			KEY: DATE								Composite label key
	 *  		},
	 *  	}
	 *
	 *  	DATE = number of days since 1970-01-01
	 *  	KEY = join('+', ["propName=FORMAT"])
	 *  	FORMAT = self::CONST
	 *
	 *  @var	hash
     */
	static protected $config;

    /**
	 * 	Whether config was changed or not
     *  @var    bool
     */
	static protected $changed = false;

    /**
	 * 	Cached value of the current day
     *  @var    int
     */
	static protected $today;

    /**
	 *  Parses automatic labels and returns the list of XN_Cache labels. Options are:
	 *  	prefix		LABEL-SPEC		Prefix for all labels with the same type. Prefix itself is also added
	 *  	extra		[LABEL-SPEC] 	Extra labels to add.
	 *  	parseQuery	bool			Parse the query url/args
	 *  	queryUrl	string			Query URL
	 *  	queryArgs	string			Query args (query string)
     *
	 *  @param      $options   hash		Options
	 *  @return     [string]
	 */
	static public function getLabels($options) {
		if (!self::$inited) {
			self::_init();
		}
		$result = array('usedProps' => array(), 'labels' => array());

		// Process prefix
		if ( isset($options['prefix']) && $options['prefix'] && ($parsedLabel = self::_parseLabel($options['prefix'])) ) {
			if ( isset($parsedLabel[0]['special']) ) {
				throw new Exception("Prefix cannot include SPECIAL labels");
			}
			$prefix = self::_addPrefixed($result, $parsedLabel, array());
			$prefix['type'] = $parsedLabel[0]['type'];
			if (count($prefix['props']) == 1) {
				self::_updatePropsUsage(array('type'=> $prefix['type'], 'prop' => key($prefix['props'])), true);
			}
		}

		// Process extra labels
		if (isset($options['extra'])) {
			foreach ($options['extra'] as $label) {
				if ($parsedLabel = self::_parseLabel($label)) {
					self::_addPrefixed($result, $parsedLabel, $prefix);
				}
			}
		}

		if (isset($options['parseQuery']) && $options['parseQuery']) {
			$info = self::_parseUrlAndArgs($options['queryUrl'], $options['queryArgs']);
			if (!$info['types']) {
				throw new Exception("Cannot find any type names in the query URL: `$options[queryUrl]'");
			}
			foreach ($info['types'] as $t) {
				unset($info['props']['id']); 			// Ignore IDs in query
				if (isset($info['sorts']['id'])) {		// in sorts ID is the same as createdDate
					unset($info['sorts']['id']);
					$info['sorts']['createddate'] = 'createdDate';
				}
				$cdate = 0;
				if (isset($info['sorts']['createddate'])) {	// Add createdDate only if there is no other labels for this type
					unset($info['sorts']['createddate']);
					$cdate = 1;
				}
				foreach (array_merge($info['props'],$info['sorts']) as $p) {
					if ( isset($result['usedProps'][$t][$p]) ) { continue; }
					$result['usedProps'][$t][$p] = 1;
					self::_addPrefixed($result, array(array('type'=>$t, 'prop'=>$p, 'format'=>self::NO_VALUE)), $prefix);
				}
				if ($cdate && !isset($result['usedProps'][$t])) {
					self::_addPrefixed($result, array(array('type'=>$t, 'special'=>1, 'crud'=>'create')), NULL);
					self::_addPrefixed($result, array(array('type'=>$t, 'special'=>1, 'crud'=>'delete')), NULL);
				}
			}
		}
		// This log line is intentionally here. Please don't remove.
		xg_log("Parsed labels for",$options," got result",$result);
		if ($result['labels']) {
			self::$changed = true;
		}
		return $result['labels'];
	}

    /**
	 *  "Content object save" event handler
     *
     *  @return     void
     */
    static public function onBeforeSave($objects) {
		if (!self::$inited) {
			self::_init();
		}
		if ($labels = self::_getChangesLabels(is_array($objects) ? $objects : array($objects), false)) {
			XN_Cache::invalidate($labels);
		}
    }

    /**
	 *  "Content object delete" event handler
     *
     *  @return     void
     */
    static public function onBeforeDelete($objects) {
		if (!self::$inited) {
			self::_init();
		}
		if ($labels = self::_getChangesLabels(is_array($objects) ? $objects : array($objects), true)) {
			XN_Cache::invalidate($labels);
		}
    }

    /**
	 *	Handles the config updates
	 *	@internal
	 *	@return void
     */
    static public function _onShutdown() {
		if (!self::$changed || serialize(self::$config) == self::$origConfig) {
    		return;
		}
		// Reload object, merge changes
		$config = Config::loadForWriting(self::$configModuleName);
		self::_mergeAndCleanupIfNecessary($config);
		Config::set($config, 'types', serialize(self::$config));
		Config::saveAndUnload($config);
	}

//** Implementation
    /**
	 *  Parses a single label
	 *  @param	$label	LABEL-SPEC	Label to parse
	 *  @return [{special,type, crud, prop,value,format,isExcluded}]
     */
	static protected function _parseLabel($label) {
		$result = array();
		$props = array();
		foreach ((array)$label as $l) {
			if (!preg_match('/^(-)?(\w+)(?:(?::(delete|create))|\.((?:my\.)?\w+)(\[L\])?(=.*)?)$/i', $l, $m)) { // |update
				throw new Exception("Malformed label `$l'");
			}
			$l = array('type' => $m[2]);
			if ( $m[3] ) {
				$l['crud'] = $m[3];
				$l['special'] = 1;
			} else {
				$l['prop'] = $m[4];
				if ( $m[1] ) {
					$l['special'] = $l['isExcluded'] = true;
				} elseif ( !$m[6] ) {
					$l['format'] = self::NO_VALUE;
				} else {
					$l['format'] = $m[5] ? self::LC_VALUE : self::VALUE;
					$l['value'] = substr($m[6],1);		// Remove "="; @non-mb
				}
			}
			if ($result) {
				if ($l['type'] != $result[0]['type']) {
					throw new Exception("Composite labels must refer to the same type");
				}
			}
			if (count($label) > 1) {
				if (isset($l['special'])) {
					throw new Exception("Composite labels cannot include SPECIAL labels");
				} else {
					if (isset($props[$l['prop']])) {
						throw new Exception("Composite labels cannot refer to the same property twice");
					}
					$props[$l['prop']] = 1;
				}
			}
			$result[] = $l;
		}
		return $result;
	}

    /**
	 *  Updates property usage in the config
     *
	 *  @param	$parsedLabel {type,crud,...}  	Parsed label
	 *  @param	$isComposite bool				Whether label is a part of a composite label
     *  @return void
     */
	static protected function _updatePropsUsage($parsedLabel, $isComposite) {
		static $map = array(self::NO_VALUE => 'noValue', self::VALUE => 'value', self::LC_VALUE => 'lcValue');
		if (isset($parsedLabel['crud'])) {
			self::$config[ $parsedLabel['type'] ][ $parsedLabel['crud'] ] = self::$today;
			return;
		}
		if (isset($parsedLabel['isExcluded'])) {
			return;
		}
		$fmt = $isComposite ? 'inComposites' : $map[ $parsedLabel['format'] ];
		self::$config[ $parsedLabel['type'] ]['props'][ $parsedLabel['prop'] ][ $fmt ] = self::$today;
	}

    /**
	 *  Appends label prefixed with $prefix to the $result and updates self::$config with usage stats.
	 *  Returns structure built in the process of adding label.
     *
	 *  @param	$result			{usedProps,labels}		Structure to keep the generated labels
	 *  @param	$parsedLabel	[{type,crud,...}]  		Parsed label (usually is a result of _parseLabel())
	 *  @param	$prefix     	{cKey,label,props,type} Prefix information
     *  @return {cKey,label,props}
     */
    static protected function _addPrefixed(array &$result, $parsedLabel, $prefix) {
		if (isset($parsedLabel[0]['special'])) {
			$l = $parsedLabel[0]; // Special label cannot be composite
			self::_updatePropsUsage($l, false);
			if ($l['isExcluded']) {
				$result['usedProps'][$l['type']][$l['prop']] = 1;
			} elseif ($l['crud']) {
				$result['labels'][] = self::$cachePrefix . self::_fmtCrudLabel($l['type'], $l['crud']);
			} else {
				throw new Exception("SPECIAL label must be either isExcluded or CRUD label:".var_export($l,true));
			}
			return;
		}

		$type = $parsedLabel[0]['type'];
		if ($prefix && $prefix['type'] == $type) {
			$base = $prefix;
		} else {
			$base = array('props' => array(), 'label' => array(), 'cKey' => array());
		}
		$isComposite = (count($parsedLabel) + count($base['label'])) > 1;
		$i = 0;
		foreach ($parsedLabel as $l) {
			if (isset($base['props'][$l['prop']])) { continue; }
			$base['props'][$l['prop']] = 1;
			$base['cKey'][] = "$l[prop]=$l[format]";
			$base['label'][] = self::_fmtPropLabel($l['type'], $l['prop'], $l['format'], isset($l['value']) ? $l['value'] : NULL);
			self::_updatePropsUsage($l, $isComposite);
			$result['usedProps'][$type][$l['prop']] = 1;
			$i++;
		}
		if ($i) {
			if ($isComposite) {
				self::$config[$type]['composites'][join('+',$base['cKey'])] = self::$today;
			}
			$result['labels'][] = self::$cachePrefix . join('+',$base['label']);
		}
		return $base;
	}

    /**
	 *  Parses the query URL and ARGS
     */
	static protected function _parseUrlAndArgs($queryUrl, $queryArgs) { # void
		static $keywords = array('like' => 1, 'in' => 1, 'likeic' => 1, 'eic' => 1, 'neic' => 1, 'null' => 1, 'friends' => 1);
		static $aliases = array('author' => 'contributorName', 'summary' => 'description', 'private' => 'isPrivate', 'published' => 'createdDate', 'updated' => 'updatedDate');

		if (!preg_match('/\((.*)\)/', $queryUrl, $m)) {
			return;
		}
		preg_match_all('/[\w.:-]+|\'(?:\\.|[^\'])*\'/', urldecode($m[1]), $m, PREG_PATTERN_ORDER); /** @non-mb */

		// For multi-type queries we can't distinguish attributes for different types, so we apply every attribute for every type
		// Parse URL
    	$sorts = $props = $types = array();
		$inType = 0;
		foreach ($m[0] as $match) {
			$l = strtolower($match); /** @non-mb */
			// Skip keywords, unquoted IDs and dates
			if (isset($keywords[$l]) || intval($match) > 1) { /** @non-mb */
				continue;
			}
			if ($match[0] == "'") {
				if ($inType) $types[substr($l,1,-1)] = stripslashes(substr($match, 1, -1)); /** @non-mb */
			} else if ($l === 'type') {
				$inType = 1;
			} else {
				if (isset($aliases[$l])) {
					$l = strtolower($match = $aliases[$l]); /** @non-mb */
				}
				$props[$l] = $match;
				$inType = 0;
			}
		}
		// Parse QUERY_STRING
		preg_match_all('/order=([\w.]+)/', $queryArgs, $m, PREG_PATTERN_ORDER); /** @non-mb */
		foreach ($m[1] as $match) {
			$l = strtolower($match); /** @non-mb */
			if (isset($aliases[$l])) {
				$l = strtolower($match = $aliases[$l]); /** @non-mb */
			}
			if ($l != 'random') { $sorts[$l] = $match; }
		}
		return array('types' => $types, 'props' => $props, 'sorts' => $sorts);
	}

    /**
	 *  Performs merging with loaded config and cleans expired items with low probability
     *
	 *  @param      $loadedConfig   XN_Content		Config object
     *  @return     void
     */
	static protected function _mergeAndCleanupIfNecessary($loadedConfig) {
		if ($loadedConfig->updatedDate != self::$origUpdatedDate) {
			if ($value = Config::get($loadedConfig, 'types')) {
				$value = unserialize($value);
			} else {
				$value = array();
			}
			self::_mergeByMaxValue(self::$config, $value);
		}

		// Run cleanup with low probability
		if (defined('UNIT_TESTING') || rand(1,100) == 1) {
			$expire = self::$today - self::$expirePeriod;
			foreach (self::$config as $t => &$type) {
				// Clean up crud
				foreach (array('create','delete'/*,'update'*/) as $n) {
					if (isset($type[$n]) && $type[$n] < $expire) { unset($type[$n]); }
				}
				$usedProps = array();
				// Clean up composites
				if (isset($type['composites'])) {
					foreach ($type['composites'] as $k => $v) {
						if ($v < $expire) { unset($type['composites'][$k]); }
						else {
							foreach (explode('+',$k) as $i) {
								list($n,$f) = explode('=', $i);
								$usedProps[$n] = 1;
							}
						}
					}
					if (!$type['composites']) { unset($type['composites']); }
				}
				// Clean up properties
				if (isset($type['props'])) {
					foreach ($type['props'] as $p => &$info) {
						if (isset($info['inComposites']) && !isset($usedProps[$p])) { unset($info['inComposites']); }
						foreach ($info as $k => $v) {
							if ($v < $expire) { unset($info[$k]); }
						}
						if (!$info) { unset($type['props'][$p]); }
					}
					if (!$type['props']) { unset($type['props']); }
				}
				if (!$type) { unset(self::$config[$t]); }
			}
		}
    }

	// Merges two arrays recursively choosing max value of every items pair
	static protected function _mergeByMaxValue(&$src, &$dest) {
    	foreach ($dest as $k => &$v) {
    		if (!isset($src[$k])) {
				$src[$k] = $v;
			} elseif (is_array($v)) {
				self::_mergeByMaxValue($src[$k], $v);
			} else {
				$src[$k] = max($src[$k], $v);
			}
		}
    }

	static protected function _init() { # void
        self::$today = intval(time() / 86400);
        $unitTesting = defined('UNIT_TESTING');

		if (!$unitTesting && $config = Config::loadForReading(self::$configModuleName)) {
			self::$origUpdatedDate = $config->updatedDate;
			self::$origConfig = Config::get($config,'types');
			self::$config = self::$origConfig ? unserialize(self::$origConfig) : array();
            Config::unload($config);
		} else {
			self::$origUpdatedDate = NULL;
			self::$origConfig = serialize(array());
			self::$config = array();
		}

		if (!$unitTesting && !self::$inited) {
			register_shutdown_function(array(__CLASS__,'_onShutdown'));
		}
		self::$inited = true;
    }

	static protected function _fmtCrudLabel($type, $crud) {
		return "$type:$crud";
    }

	static protected function _fmtPropLabel($type, $prop, $format, $value) {
		if ($format == self::NO_VALUE) {
			return "$type.$prop";
		}
		if ($format == self::LC_VALUE) {
			$value = mb_strtolower($value);
		}
		$value = strlen($value) > 32 ? md5($value) : "'" . addslashes($value) . "'"; /** @non-mb */
		return "$type.$prop=$value";
    }

	static protected function _propValues($object, $prop, $delete) {
		if ($prop == 'updateDdate') {
			$prop = 'updatedDate';
		}
		if (substr($prop,0,3) == 'my.') {
			$prop = substr($prop, 3);
			$object = $object->my;
		}
		return array($object->asLoaded($prop), $delete ? NULL : $object->$prop);
    }

    /**
	 *  Returns labels that need to be invalidated according to the changes in $objects.
     *
	 *  @param	$objects	[XN_Content]	List of changed content objects
	 *  @param	$delete		bool			Objects are being deleted
     *  @return [string]
     */
    static protected function _getChangesLabels($objects, $delete) {
		$labels = array();
		foreach ($objects as $object) {
			$create = !$object->id;
			$t = $object->type;
			if ( !isset(self::$config[$t]) || !($type =& self::$config[$t]) ) { continue; }

			if ( $create && isset($type['create'])) { $labels[] = self::$cachePrefix . self::_fmtCrudLabel($t,'create'); }
			if ( $delete && isset($type['delete'])) { $labels[] = self::$cachePrefix . self::_fmtCrudLabel($t,'delete'); }

			$values = array();
			$composite = array();
			if (isset($type['props'])) {
				foreach ($type['props'] as $p => &$info) {
					$v = self::_propValues($object, $p, $delete);
					if (isset($info['inComposites'])) {
						$values[$p] = $v; // Store fetched values
					}
					if ($v[0] === $v[1]) { continue; }
					if (isset($info['noValue'])) { $labels[] = self::$cachePrefix . self::_fmtPropLabel($t, $p, self::NO_VALUE, NULL); }
					if (isset($info['value'])) {
						if (!$create) { $labels[] = self::$cachePrefix . self::_fmtPropLabel($t, $p, self::VALUE, $v[0]); }
						if (!$delete) { $labels[] = self::$cachePrefix . self::_fmtPropLabel($t, $p, self::VALUE, $v[1]); }
					}
					if (isset($info['lcValue'])) {
						if (!$create) { $labels[] = self::$cachePrefix . self::_fmtPropLabel($t, $p, self::LC_VALUE, $v[0]); }
						if (!$delete) { $labels[] = self::$cachePrefix . self::_fmtPropLabel($t, $p, self::LC_VALUE, $v[1]); }
					}
					if (isset($info['inComposites'])) {
						$composite[$p] = 1;
					}
				}
			}
			// If any property that is included into composite label is changed and there are composite labels...1
			if ($composite && isset($type['composites'])) {
				foreach ($type['composites'] as $k => $tmp) {
					$labelOrig = $labelCur = array();
					$changed = 0;
					foreach (explode('+', $k) as $key) {
						list($p, $fmt) = explode('=', $key);
						// Any propery that is included into composite label must be refered as "isComposites" in "props", we can do this...
						$labelOrig[] = self::_fmtPropLabel($t, $p, $fmt, $values[$p][0]);
						$labelCur[] = self::_fmtPropLabel($t, $p, $fmt, $values[$p][1]);
						if (isset($composite[$p])) {
							$changed++;
						}
					}
					// We will skip all composite labels that don't include changed props
					if ($changed && !$create) { $labels[] = self::$cachePrefix . join('+', $labelOrig); }
					if ($changed && !$delete) { $labels[] = self::$cachePrefix . join('+', $labelCur); }
				}
			}
		}
		return $labels;
    }
}

XN_Event::listen('xn/content/save/before', array('XG_CachedQueryAutoLabelsHelper', 'onBeforeSave'));
XN_Event::listen('xn/content/delete/before', array('XG_CachedQueryAutoLabelsHelper', 'onBeforeDelete'));
