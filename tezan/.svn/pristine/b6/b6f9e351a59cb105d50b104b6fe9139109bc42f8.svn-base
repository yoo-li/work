/**
 * Created by clubs on 2017/4/20.
 */
Gef = createCore("Gef");

Gef.IMAGE_ROOT = "/Public/gef/images/";
// 设置流程图的边框颜色
Gef.CANVAS_STROKE = "#03689A";
// 设置流程图的填充颜色
Gef.CANVAS_FILL = "#F5DEB3";

// transition：  <event-listener
Gef.EVENT_LISTENER = "com.hunan.cs.tezan.listener.BaseTransitionListener";
//task节点 人工指定的任务分配方式
Gef.FIXED_ASSIGN_HANDLER = "com.hunan.cs.tezan.listener.FixedAssignListener";
//task节点 随机分配的任务分配方式
Gef.RANDOM_ASSIGN_HANDLER = "com.hunan.cs.tezan.listener.RandomAssignListener";
//定时任务监听器
Gef.NODE_TIMER_LISTENER = "com.hunan.cs.tezan.listener.TimerEventListener";
//Decision节点 <handler
Gef.DECISION_HANDLER = "com.hunan.cs.tezan.listener.DecisionHandler";
//进入任务节点的监听器
Gef.TASK_ENTER_HANDLER = "com.hunan.cs.tezan.listener.EnterTaskHandler";
//离开任务节点的监听器
Gef.TASK_LEAVE_HANDLER = "com.hunan.cs.tezan.listener.LeaveTaskHandler";
//进入JOIN节点的监听器
Gef.JOIN_ENTER_HANDLER = "com.hunan.cs.tezan.listener.EnterJoinHandler";
//进入会签节点的监听器
Gef.SIGN_ENTER_HANDLER = "com.hunan.cs.tezan.listener.EnterCountersignHandler";
//离开会签节点的监听器
Gef.SIGN_LEAVE_HANDLER = "com.hunan.cs.tezan.listener.LeaveCountersignHandler";
//进入子任务节点的监听器
Gef.SUB_TASK_ENTER_HANDLER = "com.hunan.cs.tezan.listener.EnterSubTaskHandler";
//离开子任务节点的监听器
Gef.SUB_TASK_LEAVE_HANDLER = "com.hunan.cs.tezan.listener.LeaveSubTaskHandler";

function createCore(_) {
	var $ = {
		svgns : "http://www.w3.org/2000/svg",
		linkns : "http://www.w3.org/1999/xlink",
		vmlns : "urn:schemas-microsoft-com:vml",
		officens : "urn:schemas-microsoft-com:office:office",
		flowid : "",
		emptyFn : function() {
		},
		emptyArray : [],
		emptyMap : {},
		installVml : function() {
			if ($.isVml) {
				document.attachEvent("onreadystatechange", function() {
					var _ = document;
					if (_.readyState == "complete") {
						if (!_.namespaces["v"])
							_.namespaces.add("v", $.vmlns);
						if (!_.namespaces["o"])
							_.namespaces.add("o", $.officens)
					}
				});
				var _ = document.createStyleSheet();
				_.cssText = "v\\:*{behavior:url(#default#VML)}"
							+ "o\\:*{behavior:url(#default#VML)}"
			}
		},
		seed : 0,
		id : function()
		{
			if (Gef.Editor.EditorInterface.editor != "undefined")
			{
				return "_" + Gef.Editor.EditorInterface.editor.id + "_svg_" + this.seed++;
			}
			else
			{
				if (!_)
					return "_INNER_" + this.seed++;
				else
					return "_" + _ + "_" + this.seed++
			}
		},
		onReady : function($) {
			window.onload = function() {
				$()
			}
		},
		debug : function() {
			if (!$.debugDiv) {
				var A = document.createElement("textarea");
				A.style.position = "absolute";
				A.rows = 10;
				A.rols = 40;
				if(typeof Gef.Editor.EditorInterface.editor != "undefined"){
					A.style.left = "0px";
					A.style.top = "0px";
					Gef.Editor.EditorInterface.editor.appendChild(A);
				}else
				{
					A.style.left = "100px";
					A.style.top = "100px";
					document.body.appendChild(A);
				}
				$.debugDiv = A
			}
			var _ = "";
			for (var B = 0; B < arguments.length; B++)
				_ += "," + arguments[B];
			$.debugDiv.value += "\n" + _
		},
		getInt : function($) {
			$ += "";
			$ = $.replace(/px/, "");
			var _ = parseInt($, 10);
			return isNaN(_) ? 0 : _
		},
		extend : function() {
			var A = function($) {
				for (var _ in $)
					this[_] = $[_]
			}, _ = Object.prototype.constructor;
			return function(F, E, D) {
				if (typeof E == "object") {
					D = E;
					E = F;
					F = D.constructor != _ ? D.constructor : function() {
						E.apply(this, arguments)
					}
				}
				var B = function() {
				}, C, G = E.prototype;
				B.prototype = G;
				C = F.prototype = new B();
				C.constructor = F;
				F.superclass = G;
				if (G.constructor == _)
					G.constructor = E;
				C.override = A;
				$.override(F, D);
				return F
			}
		}(),
		override : function(C, _) {
			if (_) {
				var A = C.prototype;
				for (var B in _)
					A[B] = _[B];
				if ($.isIE && _.toString != C.toString)
					A.toString = _.toString
			}
		},
		ns : function() {
			for (var E = 0; E < arguments.length; E++) {
				var _ = arguments[E], A = _.split("."), C = window[A[0]] = window[A[0]]
																		   || {}, $ = A.slice(1);
				for (var D = 0; D < $.length; D++) {
					var B = $[D];
					C = C[B] = C[B] || {}
				}
			}
			return C
		},
		apply : function(C, A, _) {
			if (_)
				$.apply(C, _);
			if (C && A && typeof A == "object")
				for (var B in A)
					C[B] = A[B];
			return C
		},
		applyIf : function(A, $) {
			if (A && $)
				for (var _ in $)
					if (typeof A[_] == "undefined")
						A[_] = $[_];
			return A
		},
		join : function(_) {
			var $ = "";
			for (var A = 0; A < _.length; A++)
				$ += _[A];
			return $
		},
		getTextSize : function(A) {
			if (!$.textDiv) {
				$.textDiv = document.createElement("div");
				$.textDiv.style.position = "absolute";
				$.textDiv.style.fontFamily = "Verdana";
				$.textDiv.style.fontSize = "12px";
				$.textDiv.style.left = "-1000px";
				$.textDiv.style.top = "-1000px";
				if(typeof Gef.Editor.EditorInterface.editor != "undefined"){
					Gef.Editor.EditorInterface.editor.appendChild($.textDiv)
				}else
				{
					document.body.appendChild($.textDiv)
				}
			}
			var B = $.textDiv;
			B.innerHTML = A;
			var _ = {
				w : Math.max(B.offsetWidth, B.clientWidth),
				h : Math.max(B.offsetHeight, B.clientHeight)
			};
			return _
		},
		notBlank : function($) {
			if (typeof $ == "undefined")
				return false;
			else if (typeof $ == "string" && $.trim().length == 0)
				return false;
			return true
		},
		safe : function($) {
			if ($)
				return $.trim();
			else
				return ""
		},
		get : function($) {
			return document.getElementById($)
		},
		value : function(_, B) {
			var A = $.get(_);
			if (typeof B != "undefined")
				A.value = $.safe(B);
			return $.safe(A.value)
		},
		each : function(C, A, $) {
			if (typeof C.length == "undefined" || typeof C == "string")
				C = [C];
			for (var B = 0, _ = C.length; B < _; B++)
				if (A.call($ || C[B], C[B], B, C) == false)
					return B
		}
	};
	(function() {
		var F = navigator.userAgent.toLowerCase(),
			E = F.indexOf("opera") > -1,
			B = (/webkit|khtml/).test(F),
			H = !E && F.indexOf("msie") > -1,
			_ = !E && F.indexOf("msie 7") > -1,
			A = !E && F.indexOf("msie 8") > -1,
			D = !B
																																 && F.indexOf("gecko") > -1, C = H || _ || A, G = !C;
		$.isSafari = B;
		$.isIE = H;
		$.isIE7 = _;
		$.isGecko = D;
		$.isVml = C;
		$.isSvg = G;
		if (C)
			$.installVml();
		$.applyIf(Array.prototype, {
			indexOf : function($) {
				for (var A = 0, _ = this.length; A < _; A++)
					if (this[A] == $)
						return A;
				return -1
			},
			remove : function(_) {
				var $ = this.indexOf(_);
				if ($ != -1)
					this.splice($, 1);
				return this
			}
		});
		String.prototype.trim = function() {
			var $ = /^\s+|\s+$/g;
			return function() {
				return this.replace($, "")
			}
		}()
	})();
	return $
}

Gef.ns("Gef.Event");
Gef.Event = {
	Alert : "FlowEditor.EventType.Alert",
	Info  : "FlowEditor.EventType.Info",
	Dialog : "FlowEditor.EventType.Dialog",
	DialogScreenTransition : "FlowEditor.EventType.Dialog.Screen.Transition",		//边Screen设置
	DialogScreenNode : "FlowEditor.EventType.Dialog.Screen.Node",					//节点Screen设置
	DialogPermission : "FlowEditor.EventType.Dialog.Permission",					//节点权限设置
	DialogTrend : "FlowEditor.EventType.Dialog.Trend",								//节点分支条件
	DialogTimer : "FlowEditor.EventType.Dialog.Timer",								//节点定时器设置
	DialogTask : "FlowEditor.EventType.Dialog.Task",								//节点任务设置
	DialogJoin : "FlowEditor.EventType.Dialog.Join",								//节点汇聚条件设置
	DialogSign : "FlowEditor.EventType.Dialog.Sign",								//节点会签属性设置
	DialogSubProcess : "FlowEditor.EventType.Dialog.SubProcess",					//节点设置子流程
	DialogViewSubProcess : "FlowEditor.EventType.Dialog.ViewSubProcess",			//查看子流程
	ChangeNodeName : "FlowEditor.EventType.ChangeNodeName",							//节点名修改
	ChangeTransitionName : "FlowEditor.EventType.ChangeTransitionName",				//出边名修改
	RemoveTransition : "FlowEditor.EventType.RemoveTransition",						//出边删除
	RemoveNode : "FlowEditor.EventType.RemoveNode",									//节点删除
	GetProcessParameterByNames : "FlowEditor.EventType.GetProcessParameterByNames",	//获取节点汇聚参数
	CreateNode : "FlowEditor.EventType.CreateNode",									//创建节点
	CreateTransition : "FlowEditor.EventType.CreateTransition",						//创建出边

	__events : {},
	_indexOf : function(array,obj){
		if (array == null) return -1
		var i = 0, length = array.length
		for (; i < length; i++) if (array[i] == obj) return i
		return -1
	},

	on: function (key, listener)
	{
		if (!this.__events)
		{
			this.__events = {}
		}
		if (!this.__events[key])
		{
			this.__events[key] = []
		}
		if (this._indexOf(this.__events, listener) == -1 && typeof listener == 'function')
		{
			this.__events[key].push(listener)
		}
	},
	off: function (key, listener)
	{
		if (!key && !listener)
		{
			this.__events = {}
		}
		//不传监听函数，就去掉当前key下面的所有的监听函数
		if (key && !listener)
		{
			delete this.__events[key]
		}

		if (key && listener)
		{
			var listeners = this.__events[key]
			var idx       = this._indexOf(listeners, listener)
			if (idx > -1) listeners.splice(idx, 1)
		}
	},
	trigger: function (key)
	{
		if (!this.__events || !this.__events[key]) return

		var args = Array.prototype.slice.call(arguments, 1) || []

		var listeners = this.__events[key]
		var i         = 0
		var l         = listeners.length

		for (i; i < l; i++)
		{
			listeners[i].apply(this, args)
		}
	}
};


Gef.ns("Gef.ui");
Gef.ui.WorkbenchWindow = Gef.extend(Object, {
	getActivePage : Gef.emptyFn
});
Gef.ui.WorkbenchPage = Gef.extend(Object, {
	getWorkbenchWindow : Gef.emptyFn,
	getActiveEditor : Gef.emptyFn,
	openEditor : Gef.emptyFn
});
Gef.ui.WorkbenchPart = Gef.extend(Object, {
	setWorkbenchPage : Gef.emptyFn,
	getWorkbenchPage : Gef.emptyFn
});
Gef.ui.ViewPart = Gef.extend(Object, {});
Gef.ui.EditorPart = Gef.extend(Gef.ui.WorkbenchPart, {
	init : Gef.emptyFn
});
Gef.ui.EditorInput = Gef.extend(Object, {
	getName : Gef.emptyFn,
	getObject : Gef.emptyFn
});


Gef.ns("Gef.ui.support");
Gef.ui.support.DefaultWorkbenchWindow = Gef.extend(Gef.ui.WorkbenchWindow, {
	getActivePage : function() {
		if (!this.activePage) {
			this.activePage = new Gef.ui.support.DefaultWorkbenchPage();
			this.activePage.setWorkbenchWindow(this)
		}
		return this.activePage
	},
	render : function(Interface) {
		if (!this.rendered) {
			if(Interface){
				this.width = Interface.offsetWidth;
				this.height = Interface.offsetHeight;
			}else
			{
				document.getElementsByTagName("html")[0].className += " gef-workbenchwindow";
				if (Gef.isIE)
				{
					this.width  = document.body.offsetWidth;
					this.height = document.body.offsetHeight
				}
				else
				{
					this.width  = window.innerWidth;
					this.height = window.innerHeight
				}
			}
			this.getActivePage().render();
			this.rendered = true
		}
	}
});
Gef.ui.support.DefaultWorkbenchPage = Gef.extend(Gef.ui.WorkbenchPage, {
	constructor : function($) {
		this.workbenchWindow = $
	},
	getWorkbenchWindow : function() {
		return this.workbenchWindow
	},
	setWorkbenchWindow : function($) {
		this.workbenchWindow = $
	},
	getActiveEditor : function() {
		return this.activeEditor
	},
	openEditor : function(extEditor, editorInput) {
		this.activeEditor = extEditor;
		extEditor.setWorkbenchPage(this);
		extEditor.init(editorInput)
	},
	render : function() {
		this.activeEditor.render()
	}
});
Gef.ui.support.DefaultEditorPart = Gef.extend(Gef.ui.EditorPart, {
	constructor : function($) {
		this.workbenchPage = $
	},
	getWorkbenchPage : function() {
		return this.workbenchPage
	},
	setWorkbenchPage : function($) {
		this.workbenchPage = $
	},
	init : function($) {
	},
	render : function() {
	}
});


Gef.ns("Gef.commands");
Gef.commands.Command = Gef.extend(Object, {
	execute : Gef.emptyFn,
	undo : Gef.emptyFn,
	redo : Gef.emptyFn
});
Gef.commands.CommandStack = Gef.extend(Object, {
	constructor : function() {
		this.undoList = [];
		this.redoList = [];
		this.maxUndoLength = 100
	},
	execute : function($) {
		while (this.undoList.length > this.maxUndoLength)
			this.undoList.shift();
		this.undoList.push($);
		this.redoList.splice(0, this.redoList.length);
		$.execute();
		return $
	},
	redo : function() {
		var $ = this.redoList.pop();
		if ($ != null) {
			this.undoList.push($);
			$.redo();
			return this.redoList.length > 0
		}
		return false
	},
	undo : function() {
		var $ = this.undoList.pop();
		if ($ != null) {
			while (this.redoList.length > this.maxUndoLength)
				this.redoList.shift();
			this.redoList.push($);
			$.undo();
			return this.undoList.length > 0
		}
		return false
	},
	flush : function() {
		this.flushUndo();
		this.flushRedo()
	},
	flushUndo : function() {
		this.undoList.splice(0, this.undoList.length)
	},
	flushRedo : function() {
		this.redoList.splice(0, this.redoList.length)
	},
	getMaxUndoLength : function() {
		return this.maxUndoLength
	},
	setMaxUndoLength : function($) {
		this.maxUndoLength = $
	},
	canUndo : function() {
		return this.undoList.length > 0
	},
	canRedo : function() {
		return this.redoList.length > 0
	}
});
Gef.commands.CompoundCommand = Gef.extend(Gef.commands.Command, {
	constructor : function() {
		this.commandList = []
	},
	addCommand : function($) {
		this.commandList.push($)
	},
	getCommandList : function() {
		return this.commandList
	},
	execute : function() {
		for (var $ = 0; $ < this.commandList.length; $++)
			this.commandList[$].execute()
	},
	undo : function() {
		for (var $ = this.commandList.length - 1; $ >= 0; $--)
			this.commandList[$].undo()
	},
	redo : function() {
		for (var $ = 0; $ < this.commandList.length; $++)
			this.commandList[$].redo()
	}
});


Gef.ns("Gef.gef");
Gef.gef.Editor = Gef.extend(Gef.ui.EditorPart, {
	getEditDomain : Gef.emptyFn,
	getGraphicalViewer : Gef.emptyFn,
	getModelFactory : Gef.emptyFn,
	setModelFactory : Gef.emptyFn,
	getEditPartFactory : Gef.emptyFn,
	setEditPartFactory : Gef.emptyFn
});
Gef.gef.EditPartFactory = Gef.extend(Object, {
	createEditPart : Gef.emptyFn
});
Gef.gef.ModelFactory = Gef.extend(Object, {
	createModel : Gef.emptyFn
});
Gef.gef.EditDomain = Gef.extend(Object, {
	constructor : function() {
		this.commandStack = new Gef.commands.CommandStack();
		this.editPartRegistry = {};
		this.model2EditPart = {};
		this.figure2EditPart = {}
	},
	getCommandStack : function() {
		return this.commandStack
	},
	setEditor : function($) {
		this.editor = $
	},
	createEditPart : function(_) {
		var $ = _.getId(), A = _.getType(), B = this.editor.getEditPartFactory().createEditPart(A);
		this.editPartRegistry[$] = B;
		B.setModel(_);
		this.registerModel(B);
		return B
	},
	findOrCreateEditPart : function(_) {
		var $ = _.getId(), A = _.getType(), B = this.editPartRegistry[$];
		if (!B)
			B = this.createEditPart(_);
		return B
	},
	registerModel : function(A) {
		var _ = A.getModel(), $ = _.getId();
		if (this.model2EditPart[$] != null)
			this.model2EditPart[$] = A
	},
	findModelByEditPart : function(_) {
		var $ = _.getId();
		return this.model2EditPart[$]
	},
	removeModelByEditPart : function(A) {
		var _ = A.getModel(), $ = _.getId();
		if (this.model2EditPart[$] != null) {
			this.model2EditPart[$] = null;
			delete this.model2EditPart[$]
		}
	},
	registerFigure : function(_) {
		var $ = _.getFigure(), A = $.getId();
		if (this.figure2EditPart[A] != null)
			this.figure2EditPart[A] = _
	},
	findFigureByEditPart : function($) {
		var _ = $.getId();
		return this.figure2EditPart[_]
	},
	removeFigureByEditPart : function(_) {
		var $ = _.getFigure(), A = $.getId();
		if (this.figure2EditPart[A] != null) {
			this.figure2EditPart[A] = null;
			delete this.figure2EditPart[A]
		}
	}
});
Gef.gef.EditPartViewer = Gef.extend(Object, {
	getContents : Gef.emptyFn,
	setContents : Gef.emptyFn,
	getRootEditPart : Gef.emptyFn,
	setRootEditPart : Gef.emptyFn,
	getEditDomain : Gef.emptyFn,
	setEditDomain : Gef.emptyFn
});
Gef.gef.GraphicalViewer = Gef.extend(Gef.gef.EditPartViewer, {});
Gef.gef.EditPart = Gef.extend(Object, {
	getModel : Gef.emptyFn,
	getFigure : Gef.emptyFn
});
Gef.gef.RootEditPart = Gef.extend(Gef.gef.EditPart, {
	getContents : Gef.emptyFn,
	setContents : Gef.emptyFn,
	getViewer : Gef.emptyFn,
	setViewer : Gef.emptyFn
});


Gef.ns("Gef.gef.editparts");
Gef.gef.editparts.AbstractEditPart = Gef.extend(Gef.gef.EditPart, {
	constructor : function() {
		this.children = []
	},
	getParent : function() {
		return this.parent
	},
	setParent : function($) {
		this.parent = $
	},
	getRoot : function() {
		return this.getParent().getRoot()
	},
	getChildren : function() {
		return this.children
	},
	setChildren : function($) {
		this.children = $
	},
	addChild : function($) {
		this.children.push($);
		$.setParent(this);
		this.addChildVisual($)
	},
	removeChild : function($) {
		this.removeChildVisual($);
		$.setParent(null);
		this.children.remove($)
	},
	addChildVisual : Gef.emptyFn,
	removeChildVisual : Gef.emptyFn,
	createChild : function($) {
		var _ = this.createEditPart($);
		return _
	},
	findOrCreateConnection : function($) {
		var _ = this.findOrCreateEditPart($);
		_.setSource($.getSource().getEditPart());
		_.setTarget($.getTarget().getEditPart());
		_.setParent(this.getRoot());
		this.addChildVisual(_);
		return _
	},
	createEditPart : function($) {
		return this.getViewer().editor.getEditDomain().createEditPart($)
	},
	findOrCreateEditPart : function($) {
		return this.getViewer().editor.getEditDomain().findOrCreateEditPart($)
	},
	getFigure : function() {
		if (this.figure == null || this.figure == undefined)
			this.figure = this.createFigure();
		return this.figure
	},
	createFigure : Gef.emptyFn,
	getModel : function() {
		return this.model
	},
	setModel : function($) {
		this.model = $;
		$.setEditPart(this);
		$.addChangeListener(this)
	},
	getModelChildren : function() {
		return this.model != null && this.model.children != null ? this.model.children : Gef.emptyArray
	},
	getCommand : Gef.emptyFn,
	refresh : function() {
		this.refreshVisuals();
		this.refreshChildren()
	},
	refreshVisuals : Gef.emptyFn,
	refreshChildren : function() {
		var A = {};
		for (var C = 0; C < this.getChildren().length; C++) {
			var $ = this.getChildren()[C];
			A[$.getModel().getId()] = $
		}
		for (C = 0; C < this.getModelChildren().length; C++) {
			var _ = this.getModelChildren()[C], B = A[_.getId()];
			if (B == null || B == undefined) {
				B = this.createChild(_);
				this.addChild(B)
			}
			B.refresh()
		}
	},
	getViewer : function() {
		return this.getRoot().getViewer()
	}
});
Gef.gef.editparts.AbstractGraphicalEditPart = Gef.extend(Gef.gef.editparts.AbstractEditPart, {
	addChildVisual : function(_) {
		if (_.getClass() == "node") {
			var $ = _.getFigure();
			this.getRoot().getFigure().addNode($);
			$.render()
		} else if (_.getClass() == "connection")
			if (_.getSource() != null && _.getTarget() != null) {
				$ = _.getFigure();
				if (!$.el) {
					this.getRoot().getFigure().addConnection($);
					$.render()
				}
			}
	},
	removeChildVisual : function(_) {
		var $ = _.getFigure();
		this.getFigure().removeChild($)
	},
	refresh : function() {
		Gef.gef.editparts.AbstractGraphicalEditPart.superclass.refresh.call(this);
		this.refreshSourceConnections();
		this.refreshTargetConnections()
	},
	refreshSourceConnections : function() {
		var A = {};
		for (var C = 0; C < this.getSourceConnections().length; C++) {
			var $ = this.getSourceConnections()[C];
			A[$.getModel().getId()] = $
		}
		for (C = 0; C < this.getModelSourceConnections().length; C++) {
			var _ = this.getModelSourceConnections()[C], B = A[_.getId()];
			if (B == null) {
				B = this.findOrCreateConnection(_);
				this.addSourceConnection(B)
			} else
				B.refresh()
		}
	},
	refreshTargetConnections : function() {
		var A = {};
		for (var C = 0; C < this.getTargetConnections().length; C++) {
			var $ = this.getTargetConnections()[C];
			A[$.getModel().getId()] = $
		}
		for (C = 0; C < this.getModelTargetConnections().length; C++) {
			var _ = this.getModelTargetConnections()[C], B = A[_.getId()];
			if (B == null) {
				B = this.findOrCreateConnection(_);
				this.addTargetConnection(B)
			} else
				B.refresh()
		}
	},
	addSourceConnection : function($) {
		this.getSourceConnections().push($)
	},
	addTargetConnection : function($) {
		this.getTargetConnections().push($)
	},
	notifyChanged : function(C, D) {
		if (C == "CHILD_ADDED") {
			var A = D, B = this.createChild(A);
			this.addChild(B);
			A.parent = this.model;
			B.parent = this
		} else if (C == "CHILD_REMOVED_FROM_PARENT") {
			if(this.parent != null)
			{
				this.parent.removeChild(this);
			}
			this.model.removeChangeListener(this)
		} else if (C == "NODE_MOVED")
			this.refresh();
		else if (C == "CONNECTION_SOURCE_ADDED")
			this.refresh();
		else if (C == "CONNECTION_TARGET_ADDED")
			this.refresh();
		else if (C == "NODE_RESIZED")
			this.refresh();
		else if (C == "CONNECTION_RESIZED") {
			this.getFigure().innerPoints = this.getModel().innerPoints;
			this.getFigure().modify()
		} else if (C == "TEXT_POSITION_UPDATED") {
			this.getFigure().textX = this.getModel().textX;
			this.getFigure().textY = this.getModel().textY;
			this.getFigure().modify()
		} else if (C == "TEXT_UPDATED") {
			var $ = this.getModel().text, _ = this.getFigure();
			if (typeof _.updateAndShowText != "undefined")
				_.updateAndShowText($)
		} else if (C == "CONNECTION_TEXT_UPDATED") {
			var $ = this.getModel().text, _ = this.getFigure();
			_.updateAndShowText($)
		} else if (C == "RECONNECTED") {
			this.setSource(this.getModel().getSource().getEditPart());
			this.setTarget(this.getModel().getTarget().getEditPart());
			_ = this.getFigure();
			_.from = this.getSource().getFigure();
			_.to = this.getTarget().getFigure();
			if (!_.el) {
				this.getRoot().getFigure().addConnection(_);
				_.render()
			}
			_.refresh()
		} else if (C == "DISCONNECTED") {
			this.getSource().removeSourceConnection(this);
			this.getTarget().removeTargetConnection(this);
			this.getFigure().remove();
			this.figure = null
		}
	},
	getCommand : function($) {
		switch ($.role.name) {
			case "CREATE_NODE" :
				return this.getCreateNodeCommand($);
			case "CREATE_EDGE" :
				return this.getCreateConnectionCommand($);
			case "MOVE_NODE" :
				return this.getMoveNodeCommand($);
			case "MOVE_EDGE" :
				return this.getMoveConnectionCommand($);
			case "RESIZE_NODE" :
				return this.getResizeNodeCommand($);
			case "RESIZE_EDGE" :
				return this.getResizeConnectionCommand($);
			case "MOVE_TEXT" :
				return this.getMoveTextCommand($);
			case "EDIT_TEXT" :
				return this.getEditTextCommand($);
			case "REMOVE_EDGE" :
				return this.getRemoveConnectionCommand($);
			case "REMOVE_NODES" :
				return this.getRemoveNodesCommand($);
			default :
				return null
		}
	},
	getCreateNodeCommand : function(A) {
		var _ = A.role.node, $ = this.getModel(), B = A.role.rect;
		if (!this.canCreate(_))
			return null;
		return new Gef.gef.command.CreateNodeCommand(_, $, B)
	},
	canCreate : function() {
		return true
	},
	getCreateConnectionCommand : function(B) {
		var A = B.role.source, $ = B.role.target, _ = B.role.model;
		if (this.isDuplicated(_, A, $))
			return null;
		if('sign'==A.type){//会签节点
			var signConnections = A.getSourceConnections();
			if(null != signConnections && signConnections.length>1){//会签节点有大于2的出边
				Gef.Event.trigger(Gef.Event.Alert,"会签节点只能有同意否决两条出边！")
				return null;
			}
		}
		return new Gef.gef.command.CreateConnectionCommand(_, A, $)
	},
	canCreateOutgo : function() {
		return true
	},
	canCreateIncome : function() {
		return true
	},
	isDuplicated : function(A, B, _) {
		var $ = false;
		Gef.each(B.getSourceConnections(), function(A) {
			if (A.getTarget() == _) {
				Gef.Event.trigger(Gef.Event.Alert,"相同的方向，两个节点之间只能有一条路径。")
				$ = true;
				return false
			}
		});
		return $
	},
	isTextConflict : function(event){//判断名称是否重复
		var newValue = event.role.text;
		var oldValue = this.model.text;
		var type = this.model.type;
		var i=0;
		if("transition"==type){//同一节点上的出边是不能重复的
			var otherOuterNames = [];
			var outComes = this.source.sourceConnections;
			for(i=0;i<outComes.length;i++){
				if(outComes[i].model.text != oldValue)
					otherOuterNames.push(outComes[i].model.text);
			}
			for(i=0;i<otherOuterNames.length;i++){
				if(otherOuterNames[i]==newValue){
					if(event.eventName=="MOUSE_DOWN")
						Gef.Event.trigger(Gef.Event.Alert,"同一个节点的出边不能重名！")
					return true;
				}
			}
		}else{
			var otherNodeNames = [];
			var allNodes = this.parent.children;
			for(i=0;i<allNodes.length;i++){
				if(allNodes[i].model.text!=oldValue)
					otherNodeNames.push(allNodes[i].model.text);
			}
			for(i=0;i<otherNodeNames.length;i++){
				if(otherNodeNames[i]==newValue){
					if(event.eventName=="MOUSE_DOWN")
						Gef.Event.trigger(Gef.Event.Alert,"该节点名已经存在，请重新输入！")
					return true;
				}
			}
		}
		return false;
	},
	getMoveNodeCommand : function(A) {
		var $ = A.role.dx, _ = A.role.dy;
		return new Gef.gef.command.MoveAllCommand(A.role.nodes, $, _)
	},
	getMoveConnectionCommand : function(B) {
		var A = B.role.source, $ = B.role.target, _ = this.getModel();
		if (this.isDuplicated(_, A, $))
			return null;
		if('sign'==A.type){//会签节点
			var signConnections = A.getSourceConnections();
			if(null != signConnections && signConnections.length>1){//会签节点有大于2的出边
				Gef.Event.trigger(Gef.Event.Alert,"会签节点只能有同意否决两条出边！")
				return null;
			}
		}
		return new Gef.gef.command.MoveConnectionCommand(_, A, $)
	},
	getResizeNodeCommand : function(_) {
		var $ = this.getModel(), A = _.role.rect;
		return new Gef.gef.command.ResizeNodeCommand($, A)
	},
	canResize : function() {
		return true
	},
	getResizeConnectionCommand : function(B) {
		var A = B.role.oldInnerPoints, _ = B.role.newInnerPoints, $ = this.getModel();
		return new Gef.gef.command.ResizeConnectionCommand($, A, _)
	},
	getMoveTextCommand : function(B) {
		var _ = this.getModel(), D = B.role.oldTextX, C = B.role.oldTextY, A = B.role.newTextX, $ = B.role.newTextY;
		return new Gef.gef.command.MoveTextCommand(_, D, C, A, $)
	},
	getEditTextCommand : function(A) {
		if(this.isTextConflict(A))
			return null;
		var _ = this.getModel(), $ = A.role.text;
		return new Gef.gef.command.EditTextCommand(_, $)
	},
	getRemoveConnectionCommand : function(_) {
		var $ = this.getModel();
		return new Gef.gef.command.RemoveConnectionCommand($)
	},
	getRemoveNodesCommand : function(A) {
		var B = new Gef.commands.CompoundCommand();
		try {
			var _ = [];
			Gef.each(A.role.nodes, function($) {
				Gef.each($.getSourceConnections(), function($) {
					if (_.indexOf($) == -1)
						_.push($)
				});
				Gef.each($.getTargetConnections(), function($) {
					if (_.indexOf($) == -1)
						_.push($)
				})
			});
			Gef.each(_, function($) {
				B.addCommand(new Gef.gef.command.RemoveConnectionCommand($.getModel()))
			});
			Gef.each(A.role.nodes, function($) {
				B.addCommand(new Gef.gef.command.RemoveNodeCommand($.getModel()))
			})
		} catch ($) {
			console.info($)
		}
		return B
	}
});
Gef.gef.editparts.AbstractRootEditPart = Gef.extend(Gef.gef.RootEditPart, {
	getFigure : function() {
		if (!this.figure)
			this.figure = this.createFigure();
		return this.figure
	},
	createFigure : function() {
		var $ = new Gef.gef.figures.GraphicalViewport();
		return $
	},
	getContents : function() {
		return this.contents
	},
	setContents : function($) {
		this.contents = $;
		$.setParent(this)
	},
	getViewer : function() {
		return this.viewer
	},
	setViewer : function($) {
		this.viewer = $
	},
	getRoot : function() {
		return this
	}
});
Gef.gef.editparts.ConnectionEditPart = Gef.extend(Gef.gef.editparts.AbstractGraphicalEditPart, {
	getClass : function() {
		return "connection"
	},
	getSource : function() {
		return this.source
	},
	setSource : function($) {
		this.source = $
	},
	getTarget : function() {
		return this.target
	},
	setTarget : function($) {
		this.target = $
	},
	refresh : function() {
		this.refreshVisuals()
	},
	refreshVisuals : function() {
		var $ = this.getModel().getSource(),
			_ = this.getModel().getTarget();
		if ($ != null && _ != null)
			this.getFigure().refresh();
		else
			this.getFigure().update(0, 0, 0, 0)
	},
	notifyChanged : function(_, A) {
		if (_ == "CONDITION_CHANGED") {
			var $ = this.getFigure();
			if (typeof A == "string" && A != null && A != "") {
				$.setConditional(true);
				$.updateAndShowText(A)
			} else
				$.setConditional(false)
		} else
			Gef.gef.editparts.ConnectionEditPart.superclass.notifyChanged.call(this, _, A)
	}
});
Gef.gef.editparts.NodeEditPart = Gef.extend(Gef.gef.editparts.AbstractGraphicalEditPart, {
	getClass : function() {
		return "node"
	},
	getSourceConnections : function() {
		if (!this.sourceConnections)
			this.sourceConnections = [];
		return this.sourceConnections
	},
	getModelSourceConnections : function() {
		return this.getModel().getSourceConnections()
	},
	removeSourceConnection : function($) {
		if ($.getSource() == this)
			this.getSourceConnections().remove($)
	},
	getTargetConnections : function() {
		if (!this.targetConnections)
			this.targetConnections = [];
		return this.targetConnections
	},
	getModelTargetConnections : function() {
		return this.getModel().getTargetConnections()
	},
	removeTargetConnection : function($) {
		if ($.getTarget() == this)
			this.getTargetConnections().remove($)
	},
	refreshVisuals : function() {
		var $ = this.getModel(), _ = this.getFigure();
		_.update($.x, $.y, $.w, $.h)
	}
});


Gef.ns("Gef.gef.command");
Gef.gef.command.CreateNodeCommand = Gef.extend(Gef.commands.Command, {
	constructor : function(_, $, A) {
		this.childNode = _;
		this.parentNode = $;
		this.rect = A
	},
	execute : function() {
		this.childNode.x = this.rect.x;
		this.childNode.y = this.rect.y;
		this.childNode.w = this.rect.w;
		this.childNode.h = this.rect.h;
		this.redo()
		Gef.Event.trigger(Gef.Event.CreateNode,this.childNode.type,this.childNode.text);
	},
	redo : function() {
		this.parentNode.addChild(this.childNode)
	},
	undo : function() {
		this.parentNode.removeChild(this.childNode)
	}
});
Gef.gef.command.CreateConnectionCommand = Gef.extend(Gef.commands.Command, {
	constructor : function(_, A, $) {
		this.connection = _;
		this.sourceNode = A;
		this.targetNode = $
	},
	execute : function() {
		this.connection.setSource(this.sourceNode);
		this.connection.setTarget(this.targetNode);
		this.redo()
		Gef.Event.trigger(Gef.Event.CreateTransition,this.sourceNode.text,this.targetNode.text,this.connection.text)
	},
	redo : function() {
		this.connection.reconnect()
	},
	undo : function() {
		this.connection.disconnect()
	}
});
Gef.gef.command.MoveNodeCommand = Gef.extend(Gef.commands.Command, {
	constructor : function($, _) {
		this.node = $;
		this.rect = _
	},
	execute : function() {
		this.oldX = this.node.x;
		this.oldY = this.node.y;
		this.newX = this.rect.x;
		this.newY = this.rect.y;
		this.redo()
	},
	redo : function() {
		this.node.moveTo(this.newX, this.newY)
	},
	undo : function() {
		this.node.moveTo(this.oldX, this.oldY)
	}
});
Gef.gef.command.MoveConnectionCommand = Gef.extend(Gef.commands.Command, {
	constructor : function(_, A, $) {
		this.connection = _;
		this.sourceNode = A;
		this.targetNode = $
	},
	execute : function() {
		this.oldSourceNode = this.connection.getSource();
		this.oldTargetNode = this.connection.getTarget();
		this.newSourceNode = this.sourceNode;
		this.newTargetNode = this.targetNode;
		this.redo()
	},
	redo : function() {
		this.connection.setSource(this.newSourceNode);
		this.connection.setTarget(this.newTargetNode);
		this.connection.reconnect()
	},
	undo : function() {
		this.connection.setSource(this.oldSourceNode);
		this.connection.setTarget(this.oldTargetNode);
		this.connection.reconnect()
	}
});
Gef.gef.command.ResizeNodeCommand = Gef.extend(Gef.commands.Command, {
	constructor : function($, _) {
		this.node = $;
		this.rect = _
	},
	execute : function() {
		this.oldX = this.node.x;
		this.oldY = this.node.y;
		this.oldW = this.node.w;
		this.oldH = this.node.h;
		this.newX = this.rect.x;
		this.newY = this.rect.y;
		this.newW = this.rect.w;
		this.newH = this.rect.h;
		this.redo()
	},
	redo : function() {
		this.node.resize(this.newX, this.newY, this.newW, this.newH)
	},
	undo : function() {
		this.node.resize(this.oldX, this.oldY, this.oldW, this.oldH)
	}
});
Gef.gef.command.ResizeConnectionCommand = Gef.extend(Gef.commands.Command, {
	constructor : function($, A, _) {
		this.connection = $;
		this.oldInnerPoints = A;
		this.newInnerPoints = _
	},
	execute : function() {
		this.redo()
	},
	redo : function() {
		this.connection.resizeConnection(this.newInnerPoints)
	},
	undo : function() {
		this.connection.resizeConnection(this.oldInnerPoints)
	}
});
Gef.gef.command.RemoveNodeCommand = Gef.extend(Gef.commands.Command, {
	constructor : function($) {
		this.node = $;
		this.parentNode = $.getParent()
	},
	execute : function() {
		this.redo()
	},
	redo : function() {
		this.node.removeForParent()
	},
	undo : function() {
		var _ = this.node, $ = this.parentNode;
		$.addChild(_)
	}
});
Gef.gef.command.RemoveConnectionCommand = Gef.extend(Gef.commands.Command, {
	constructor : function($) {
		this.connection = $;
		this.sourceNode = $.getSource();
		this.targetNode = $.getTarget()
	},
	execute : function() {
		this.redo()
	},
	redo : function() {
		this.connection.disconnect()
	},
	undo : function() {
		this.connection.reconnect()
	}
});
Gef.gef.command.MoveTextCommand = Gef.extend(Gef.commands.Command, {
	constructor : function(_, C, B, A, $) {
		this.connection = _;
		this.oldTextX = C;
		this.oldTextY = B;
		this.newTextX = A;
		this.newTextY = $
	},
	execute : function() {
		this.redo()
	},
	redo : function() {
		this.connection.updateTextPosition(this.newTextX, this.newTextY)
	},
	undo : function() {
		this.connection.updateTextPosition(this.oldTextX, this.oldTextY)
	}
});
Gef.gef.command.EditTextCommand = Gef.extend(Gef.commands.Command, {
	constructor : function(_, $) {
		this.model = _;
		this.oldText = _.name;
		this.newText = $
	},
	execute : function() {
		var type = this.model.type;
		var newName = this.newText;
		var oldName = this.model.text;
		if("transition"==type){//改变边的名称
			var srcNodeName = this.model.source.text;
			Gef.Event.trigger(Gef.Event.ChangeTransitionName,newName,oldName,srcNodeName);
		}else{//改变节点的名称
			var outTransitions = this.model.sourceConnections;
			var outTransitionNames = [];
			if(null != outTransitions && outTransitions>0){
				for(var i=0;i<outTransitions.length;i++){
					outTransitionNames.push(outTransitions[i].text);
				}
			}
			var reg_normal = new RegExp("^(?!_)(?!.*?_$)[ a-zA-Z0-9_\u4e00-\u9fa5]+$");
			if(!reg_normal.test(newName)){
				Gef.Event.trigger(Gef.Event.Alert,"节点名称只允许输入汉字、数字、字母、下划线，不能以下划线开头和结尾！")
				return ;
			}
			Gef.Event.trigger(Gef.Event.ChangeNodeName,newName,oldName,outTransitionNames);
		}
		this.redo()
	},
	redo : function() {
		this.model.updateText(this.newText)
	},
	undo : function() {
		this.model.updateText(this.oldText)
	}
});
Gef.gef.command.MoveAllCommand = Gef.extend(Gef.commands.Command, {
	constructor : function(A, $, _) {
		this.nodes = A;
		this.dx = $;
		this.dy = _;
		var B = [];
		Gef.each(A, function($) {
			Gef.each($.getSourceConnections(), function($) {
				Gef.each(A, function(_) {
					if ($.getTarget() == _)
						B.push($)
				})
			})
		});
		this.connections = B
	},
	execute : function() {
		this.redo()
	},
	redo : function() {
		var A = this.nodes, $ = this.dx, _ = this.dy;
		Gef.each(A, function(A) {
			A.moveTo(A.x + $, A.y + _)
		});
		Gef.each(this.connections, function(A) {
			var B = A.innerPoints;
			Gef.each(B, function(A) {
				A[0] += $;
				A[1] += _
			});
			A.resizeConnection(B)
		})
	},
	undo : function() {
		var A = this.nodes, $ = this.dx, _ = this.dy;
		Gef.each(A, function(A) {
			A.moveTo(A.x - $, A.y - _)
		});
		Gef.each(this.connections, function(A) {
			var B = A.innerPoints;
			Gef.each(B, function(A) {
				A[0] -= $;
				A[1] -= _
			});
			A.resizeConnection(B)
		})
	}
});


Gef.ns("Gef.gef.xml");
Gef.gef.xml.XmlSerializer = function($) {
	this.model = $;
	this.map = {
		"node" : Gef.xml.AbstractWrapper
	}
};
Gef.gef.xml.XmlSerializer.prototype = {
	serialize : function() {
		var $ = [];
		this.appendToBuffer($);
		return Gef.join($)
	},
	appendToBuffer : function($) {
		$.push("<?xml version='1.0' encoding='UTF-8'?>\n");
		$.push("<node>\n");
		this.appendBody($);
		$.push("</node>")
	},
	appendBody : function($) {
		Gef.each(this.model.getChildren(), function(A) {
			var _ = this.getWrapper(A);
			_.appendBuffer($)
		}, this)
	},
	getWrapper : function(node) {
		var type = node.type, A = this.map[type];
		if (!A)
			return {
				appendBuffer : Gef.emptyFn
			};
		else
			return new A(node)
	}
};
Gef.gef.xml.AbstractWrapper = function($) {
	this.node = $
};
Gef.gef.xml.AbstractWrapper.prototype = {
	appendBuffer : function(_) {
		this.appendHeader(_);
		this.appendAttributes(_);
		var $ = [];
		this.appendBody($);
		this.appendFooter(_, $)
	},
	appendHeader : function($) {
		var nodeType = this.node.getType();
		if('endCancel'==nodeType)
			nodeType = 'end-cancel';
		$.push("  <", nodeType);
	},
	appendAttributes : function(_) {
		var $ = this.node;
		_.push(" text='", $.text, "' g='", $.x, ",", $.y, ",", $.w, ",", $.h, "'")
	},
	appendBody : function($) {
		Gef.each(this.node.getSourceConnections(), function(_) {
			$.push("    <transition");
			if (_.text != null && _.text != "")
				$.push(" name='", _.text);
			$.push("' to='", _.getTarget().text, "'/>\n")
		})
	},
	appendFooter : function(_, $) {
		var nodeType = this.node.getType();
		if('endCancel'==nodeType)
			nodeType = 'end-cancel';
		if ($.length == 0)
			_.push("/>\n");
		else
			_.push(">\n", Gef.join($), "  </", nodeType, ">\n")
	}
};
Gef.gef.xml.XmlDeserializer = Gef.extend(Object, {
	constructor : function(_) {
		var $ = null;
		if (typeof(DOMParser) == "undefined") {
			$ = new ActiveXObject("Microsoft.XMLDOM");
			$.async = "false";
			$.loadXML(_)
		} else {
			var A = new DOMParser();
			$ = A.parseFromString(_, "application/xml");
			A = null
		}
		this.xdoc = $
	}
});


Gef.ns("Gef.gef.support");
Gef.gef.support.AbstractGraphicalEditor = Gef.extend(Gef.gef.Editor, {
	constructor : function() {
		this.editDomain = this.createEditDomain();
		this.graphicalViewer = this.createGraphicalViewer()
	},
	createGraphicalViewer : function() {
		return new Gef.gef.GraphicalViewer()
	},
	getGraphicalViewer : function() {
		return this.graphicalViewer
	},
	setGraphicalViewer : function($) {
		this.graphicalViewer = $
	},
	createEditDomain : function() {
		var $ = new Gef.gef.EditDomain();
		$.setEditor(this);
		return $
	},
	setEditDomain : function($) {
		this.editDomain = $
	},
	getEditDomain : function() {
		return this.editDomain
	},
	getModelFactory : function() {
		return this.modelFactory
	},
	setModelFactory : function($) {
		this.modelFactory = $
	},
	getEditPartFactory : function() {
		return this.editPartFactory
	},
	setEditPartFactory : function($) {
		this.editPartFactory = $
	},
	enable : function() {
		this.getGraphicalViewer().getBrowserListener().enable()
	},
	disable : function() {
		this.getGraphicalViewer().getBrowserListener().disable()
	},
	addWidth : function($) {
		if (Gef.isVml)
			;
		else {
			var svgId = document.getElementById("__gef_simple_center__").childNodes[0].id;
			var _ = document.getElementById(svgId), A = parseInt(_.getAttribute("width"), 10);
			_.setAttribute("width", A + $)
		}
	},
	addHeight : function($) {
		if (Gef.isVml)
			;
		else {
			var svgId = document.getElementById("__gef_simple_center__").childNodes[0].id;
			var A = document.getElementById(svgId);
			var _ = parseInt(A.getAttribute("height"), 10);
			A.setAttribute("height", _ + $)
		}
	}
});
Gef.gef.support.DefaultGraphicalEditorWithPalette = Gef.extend(Gef.gef.support.AbstractGraphicalEditor, {
	init : function($) {
		var _ = $.getObject();
		this.getGraphicalViewer().setContents(_);
		this.editDomain = new Gef.gef.EditDomain();
		this.editDomain.setEditor(this)
	},
	setWorkbenchPage : function($) {
		this.workbenchPage = $
	},
	getPaletteHelper : function() {
		if (!this.paletteHelper)
			this.paletteHelper = this.createPaletteHelper();
		return this.paletteHelper
	},
	createPaletteHelper : Gef.emptyFn,
	createGraphicalViewer : function() {
		return new Gef.gef.support.DefaultGraphicalViewer(this)
	},
	render : function() {
		this.getGraphicalViewer().render()
	}
});
Gef.gef.support.AbstractEditPartViewer = Gef.extend(Gef.gef.EditPartViewer, {
	getContents : function() {
		return this.rootEditPart.getContents()
	},
	setContents : function($) {
		this.rootEditPart.setContents($)
	},
	getRootEditPart : function() {
		return this.rootEditPart
	},
	setRootEditPart : function($) {
		this.rootEditPart = $
	},
	getEditDomain : Gef.emptyFn,
	setEditDomain : Gef.emptyFn
});
Gef.gef.support.AbstractGraphicalViewer = Gef.extend(Gef.gef.support.AbstractEditPartViewer, {});
//绘图部分
Gef.gef.support.DefaultGraphicalViewer = Gef.extend(Gef.gef.support.AbstractGraphicalViewer, {
	constructor : function($) {
		this.editor = $;
		this.rootEditPart = this.createRootEditPart();
		Gef.gef.support.DefaultGraphicalViewer.superclass.constructor.call(this);
		this.browserListener = new Gef.gef.tracker.BrowserListener(this)
	},
	getActivePalette : function() {
		return this.editor.getPaletteHelper().getActivePalette()
	},
	createRootEditPart : function() {
		return new Gef.gef.support.DefaultRootEditPart(this)
	},
	getEditDomain : function() {
		return this.editor.getEditDomain()
	},
	getEditPartFactory : function() {
		return this.editor.editPartFactory
	},
	setContents : function(_) {
		var $ = null, D = null;
		if (typeof _ == "string") {
			D = _;
			var C = this.editor.getModelFactory();
			$ = C.createModel(_)
		} else {
			$ = _;
			D = $.getType()
		}
		var B = this.editor.getEditPartFactory(), A = B.createEditPart(D);
		A.setModel($);
		this.rootEditPart.setContents(A)
	},
	getLayer : function($) {
		return this.rootEditPart.getFigure().getLayer($)
	},
	getPaletteConfig : function(_, $) {
		return this.editor.getPaletteHelper().getPaletteConfig(_, $)
	},
	render : function() {
		if (this.rendered == true)
			return;
		var A = this.editor.workbenchPage.getWorkbenchWindow().width - 2,
			$ = this.editor.workbenchPage.getWorkbenchWindow().height - 2,
			_ = document.createElement("div");
		_.className = "gef-workbenchpage";
		_.style.width = A + "px";
		_.style.height = $ + "px";
		if(typeof Gef.Editor.EditorInterface.editor != "undefined"){
			Gef.Editor.EditorInterface.editor.appendChild(_);
		}else
		{
			document.body.appendChild(_);
		}
		this.el = _;
		var C = document.createElement("div");
		C.className = "gef-canvas";
		C.style.position = "absolute";
		C.style.left = "50px";
		C.style.top = "50px";
		C.style.border = "1px solid black";
		C.style.width = (A - 216) + "px";
		C.style.height = $ + "px";
		_.appendChild(C);
		this.canvasEl = C;
		var B = document.createElement("div");
		B.className = "gef-palette";
		B.style.left = (A - 216) + "px";
		B.style.width = "199px";
		B.style.height = $ + "px";
		_.appendChild(B);
		this.paletteEl = B;
		this.editor.getPaletteHelper().render(B);
		this.rootEditPart.render();
		this.rendered = true
	},
	getPaletteLocation : function() {
		var $ = this.paletteEl;
		if (!this.paletteLocation)
			this.paletteLocation = {
				x : Gef.getInt($.style.left),
				y : Gef.getInt($.style.top),
				w : Gef.getInt($.style.width),
				h : Gef.getInt($.style.height)
			};
		return this.paletteLocation
	},
	getCanvasLocation : function() {
		var $ = this.canvasEl;
		if (!this.canvasLocation)
			this.canvasLocation = {
				x : Gef.getInt($.style.left),
				y : Gef.getInt($.style.top),
				w : Gef.getInt($.style.width),
				h : Gef.getInt($.style.height)
			};
		return this.canvasLocation
	},
	getEditor : function() {
		return this.editor
	},
	getBrowserListener : function() {
		return this.browserListener
	}
});
Gef.gef.support.DefaultRootEditPart = Gef.extend(Gef.gef.editparts.AbstractRootEditPart, {
	constructor : function($) {
		Gef.gef.support.DefaultRootEditPart.superclass.constructor.call(this);
		this.setViewer($);
		this.figure = this.createFigure()
	},
	createFigure : function() {
		return new Gef.gef.figures.GraphicalViewport(this)
	},
	getParentEl : function() {
		return this.getViewer().canvasEl
	},
	render : function() {
		this.figure.render();
		this.getContents().refresh()
	}
});
Gef.gef.support.PaletteHelper = Gef.extend(Object, {
	getSource : Gef.emptyFn,
	render : Gef.emptyFn,
	getPaletteConfig : Gef.emptyFn
});


Gef.ns("Gef.model");
Gef.model.Model = Gef.extend(Object, {
	constructor : function($) {
		this.listeners = [];
		$ = $ ? $ : {};
		Gef.apply(this, $)
	},
	addChangeListener : function($) {
		this.listeners.push($)
	},
	removeChangeListener : function($) {
		this.listeners.remove($)
	},
	notify : function($, _) {
		for (var A = 0; A < this.listeners.length; A++)
			this.listeners[A].notifyChanged($, _)
	},
	getId : function() {
		if (this.id == null || this.id == undefined)
			this.id = Gef.id();
		return this.id
	},
	getType : function() {
		if (this.type == null || this.type == undefined)
			this.type = "node";
		return this.type
	},
	getEditPart : function() {
		return this.editPart
	},
	setEditPart : function($) {
		this.editPart = $
	}
});
Gef.model.ModelChangeListener = Gef.extend(Object, {
	notifyChanged : Gef.emptyFn
});
Gef.model.NodeModel = Gef.extend(Gef.model.Model, {
	CHILD_ADDED : "CHILD_ADDED",
	NODE_MOVED : "NODE_MOVED",
	NODE_RESIZED : "NODE_RESIZED",
	TEXT_UPDATED : "TEXT_UPDATED",
	CONNECTION_SOURCE_ADDED : "CONNECTION_SOURCE_ADDED",
	CONNECTION_TARGET_ADDED : "CONNECTION_TARGET_ADDED",
	CHILD_REMOVED_FROM_PARENT : "CHILD_REMOVED_FROM_PARENT",
	constructor : function($) {
		this.text = "untitled";
		this.x = 0;
		this.y = 0;
		this.w = 0;
		this.h = 0;
		this.rotate = 0;
		this.children = [];
		this.sourceConnections = [];
		this.targetConnections = [];
		Gef.model.NodeModel.superclass.constructor.call(this, $)
	},
	getText : function() {
		return this.text
	},
	setParent : function($) {
		this.parent = $
	},
	getParent : function() {
		return this.parent
	},
	setChildren : function($) {
		this.children = $
	},
	getChildren : function() {
		return this.children
	},
	addChild : function($) {
		this.children.push($);
		$.setParent(this);
		this.notify(this.CHILD_ADDED, $)
	},
	removeChild : function($) {
		this.children.remove($);
		$.setParent(null);
		$.notify(this.CHILD_REMOVED_FROM_PARENT, $)
	},
	getSourceConnections : function() {
		return this.sourceConnections
	},
	getTargetConnections : function() {
		return this.targetConnections
	},
	addSourceConnection : function($) {
		if ($.getSource() == this && this.sourceConnections.indexOf($) == -1) {
			this.sourceConnections.push($);
			this.notify(this.CONNECTION_SOURCE_ADDED)
		}
	},
	addTargetConnection : function($) {
		if ($.getTarget() == this && this.targetConnections.indexOf($) == -1) {
			this.targetConnections.push($);
			this.notify(this.CONNECTION_TARGET_ADDED)
		}
	},
	removeSourceConnection : function($) {
		if ($.getSource() == this && this.sourceConnections.indexOf($) != -1)
			this.sourceConnections.remove($)
	},
	removeTargetConnection : function($) {
		if ($.getTarget() == this && this.targetConnections.indexOf($) != -1)
			this.targetConnections.remove($)
	},
	moveTo : function(_, $) {
		this.x = _;
		this.y = $;
		this.notify(this.NODE_MOVED)
	},
	resize : function(B, A, $, _) {
		this.x = B;
		this.y = A;
		this.w = $;
		this.h = _;
		this.notify(this.NODE_RESIZED)
	},
	updateText : function($) {
		this.text = $;
		this.notify(this.TEXT_UPDATED)
	},
	removeForParent : function() {
		this.parent.removeChild(this);
		this.notify(this.CHILD_REMOVED_FROM_PARENT)
	}
});
Gef.model.ConnectionModel = Gef.extend(Gef.model.Model, {
	RECONNECTED : "RECONNECTED",
	DISCONNECTED : "DISCONNECTED",
	CONNECTION_RESIZED : "CONNECTION_RESIZED",
	CONNECTION_TEXT_UPDATED : "CONNECTION_TEXT_UPDATED",
	TEXT_POSITION_UPDATED : "TEXT_POSITION_UPDATED",
	constructor : function($) {
		this.x1 = 0;
		this.y1 = 0;
		this.x2 = 0;
		this.y2 = 0;
		this.text = "untitled";
		this.textX = 0;
		this.textY = 0;
		this.innerPoints = [];
		Gef.model.ConnectionModel.superclass.constructor.call(this, $)
	},
	getText : function() {
		return this.text
	},
	getSource : function() {
		return this.source
	},
	setSource : function($) {
		this.source = $
	},
	getTarget : function() {
		return this.target
	},
	setTarget : function($) {
		this.target = $
	},
	reconnect : function() {
		this.notify(this.RECONNECTED);
		this.source.addSourceConnection(this);
		this.target.addTargetConnection(this)
	},
	disconnect : function() {
		this.notify(this.DISCONNECTED);
		this.source.removeSourceConnection(this);
		this.target.removeTargetConnection(this)
	},
	resizeConnection : function($) {
		this.innerPoints = $;
		this.notify(this.CONNECTION_RESIZED)
	},
	updateText : function($) {
		this.text = $;
		this.notify(this.CONNECTION_TEXT_UPDATED)
	},
	updateTextPosition : function(_, $) {
		this.textX = _;
		this.textY = $;
		this.notify(this.TEXT_POSITION_UPDATED)
	}
});


Gef.ns("Gef.gef.tracker");
Gef.gef.tracker.BrowserListener = Gef.extend(Object, {
	constructor : function($) {
		this.graphicalViewer = $;
		this.selectionManager = new Gef.gef.tracker.SelectionManager(this);
		this.enabled = true;
		this.dragging = false;
		this.initTrackers();
		this.initEvents(Gef.Editor.EditorInterface.editor)
	},
	initTrackers : function() {
		this.trackers = [];
		this.trackers.push(new Gef.gef.tracker.DirectEditRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.ToolTracker(this));
		this.trackers.push(new Gef.gef.tracker.SelectionRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.CreateNodeRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.CreateEdgeRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.ResizeNodeRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.ResizeEdgeRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.MoveEdgeRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.MoveNodeRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.MoveTextRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.MarqueeRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.RemoveRequestTracker(this));
		this.trackers.push(new Gef.gef.tracker.SelectionListenerTracker(this))
	},
	initEvents : function($) {
		this.initMouseDownEvent($);
		this.initMouseMoveEvent($);
		this.initMouseUpEvent($);
		this.initDoubleClickEvent($);
		this.initKeyDownEvent($)
	},
	initMouseDownEvent : function(obj) {
		var $ = this, _ = function(A) {
			var _ = Gef.isIE ? event : A;
			$.mouseDown(_)
		};
		if(typeof obj != "undefined"){
			if (Gef.isIE)
				obj.attachEvent("onmousedown", _);
			else
				obj.addEventListener("mousedown", _, false)
		}else
		{
			if (Gef.isIE)
				document.attachEvent("onmousedown", _);
			else
				document.addEventListener("mousedown", _, false)
		}
	},
	initMouseMoveEvent : function(obj) {
		var $ = this, _ = function(A) {
			var _ = Gef.isIE ? event : A;
			$.mouseMove(_)
		};
		if(typeof obj != "undefined"){
			if (Gef.isIE)
				obj.attachEvent("onmousemove", _);
			else
				obj.addEventListener("mousemove", _, false)
		}else
		{
			if (Gef.isIE)
				document.attachEvent("onmousemove", _);
			else
				document.addEventListener("mousemove", _, false)
		}
	},
	initMouseUpEvent : function(obj) {
		var $ = this, _ = function(A) {
			var _ = Gef.isIE ? event : A;
			$.mouseUp(_)
		};
		if(typeof obj != "undefined"){
			if (Gef.isIE)
				obj.attachEvent("onmouseup", _);
			else
				obj.addEventListener("mouseup", _, false)
		}else
		{
			if (Gef.isIE)
				document.attachEvent("onmouseup", _);
			else
				document.addEventListener("mouseup", _, false)
		}
	},
	initDoubleClickEvent : function(obj) {
		var $ = this, _ = function(A) {
			var _ = Gef.isIE ? event : A;
			$.doubleClick(_)
		};
		if(typeof obj != "undefined"){
			if (Gef.isIE)
				obj.attachEvent("ondblclick", _);
			else
				obj.addEventListener("dblclick", _, false)
		}else
		{
			if (Gef.isIE)
				document.attachEvent("ondblclick", _);
			else
				document.addEventListener("dblclick", _, false)
		}
	},
	initKeyDownEvent : function(obj) {
		var $ = this, _ = function(A) {
			var _ = Gef.isIE ? event : A;
			$.keyDown(_)
		};
		if(typeof obj != "undefined"){
			if (Gef.isIE)
				obj.attachEvent("onkeydown", _);
			else
				obj.addEventListener("keydown", _, false)
		}else
		{
			if (Gef.isIE)
				document.attachEvent("onkeydown", _);
			else
				document.addEventListener("keydown", _, false)
		}
	},
	fireEvent : function(C, _) {
		if (this.enabled != true)
			return;
		var $ = this.getXY(_),
			B = this.getTarget(_),
			A = {
				e : _,
				eventName : C,
				point : $,
				target : B
			};
		try {
			Gef.each(this.trackers, function($) {
				if ($.understandRequest(A))
					$.processRequest(A)
			})
			if(C == "MOUSE_DOWN" && _.button == 2)
			{
				this.fireEvent("MOUSE_UP", _)
			}
		} catch (_) {
			console.error(_)
		}
		if (A.draggingType || A.selectType)
			this.stopEvent(_)
	},
	mouseDown : function($) {
		if(jQuery(".x-menu").length > 0){
			var index = jQuery(".x-menu").length -1;
			if(jQuery(jQuery(".x-menu")[index]).css("visibility") == 'visible')
			{
				return false;
			}
		}
		this.fireEvent("MOUSE_DOWN", $)
	},
	mouseMove : function($) {
		this.fireEvent("MOUSE_MOVE", $)
	},
	mouseUp : function($) {
		if(jQuery(".x-menu").length > 0){
			var index = jQuery(".x-menu").length -1;
			if(jQuery(jQuery(".x-menu")[index]).css("visibility") == 'visible')
			{
				return false;
			}
		}
		this.fireEvent("MOUSE_UP", $)
	},
	doubleClick : function($) {
		this.fireEvent("DBL_CLICK", $)
	},
	keyDown : function($) {
		this.fireEvent("KEY_DOWN", $)
	},
	getXY : function($) {
		var _ = {};
		if (typeof window.pageYOffset != "undefined")
		{
			_.x = window.pageXOffset;
			_.y = window.pageYOffset
		}
		else if (typeof document.compatMode != "undefined"
				 && document.compatMode != "BackCompat")
		{
			_.x = document.documentElement.scrollLeft;
			_.y = document.documentElement.scrollTop
		}
		else if (typeof document.body != "undefined")
		{
			_.x = document.body.scrollLeft;
			_.y = document.body.scrollTop
		}
		var C = this.graphicalViewer.getCanvasLocation(),
			B = $.clientX + _.x,
			A = $.clientY + _.y;
		return {
			x : B - C.x,
			y : A - C.y,
			absoluteX : B,
			absoluteY : A
		}
	},
	getTarget : function($) {
		return Gef.isIE ? $.srcElement : $.target
	},
	stopEvent : function($) {
		if (Gef.isIE)
			$.returnValue = false;
		else
			$.preventDefault()
	},
	getViewer : function() {
		return this.graphicalViewer
	},
	getSelectionManager : function() {
		return this.selectionManager
	},
	disable : function() {
		this.enabled = false
	},
	enable : function() {
		this.enabled = true
	}
});
Gef.gef.tracker.RequestTracker = Gef.extend(Object, {
	understandRequest : Gef.emptyFn,
	processRequest : Gef.emptyFn
});
Gef.gef.tracker.AbstractRequestTracker = Gef.extend(Gef.gef.tracker.RequestTracker, {
	constructor : function($) {
		this.browserListener = $;
		this.reset()
	},
	reset : function() {
		this.status = "NONE";
		this.temp = {}
	},
	getDraggingRect : function() {
		if (!this.draggingRect) {
			this.draggingRect = new Gef.figure.DraggingRectFigure({
																	  x : -90,
																	  y : -90,
																	  w : 48,
																	  h : 48
																  });
			this.getDraggingLayer().addChild(this.draggingRect);
			this.draggingRect.render()
		}
		return this.draggingRect
	},
	createDraggingRects : function() {
		if (!this.draggingRects)
			this.draggingRects = [];
		var $ = new Gef.figure.DraggingRectFigure({
													  x : -90,
													  y : -90,
													  w : 48,
													  h : 48
												  });
		this.getDraggingLayer().addChild($);
		$.render();
		this.draggingRects.push($);
		return $
	},
	getDraggingRects : function($) {
		return this.draggingRects[$]
	},
	removeDraggingRects : function($) {
		Gef.each(this.draggingRects, function($) {
			$.remove()
		}, this);
		this.draggingRects = []
	},
	getDraggingEdge : function() {
		if (!this.draggingEdge) {
			this.draggingEdge = new Gef.figure.DraggingEdgeFigure({
																	  x1 : -1,
																	  y1 : -1,
																	  x2 : -1,
																	  y2 : -1
																  });
			this.getDraggingLayer().addChild(this.draggingEdge);
			this.draggingEdge.render()
		}
		return this.draggingEdge
	},
	isInPalette : function($) {
		return this
			.isIn($, this.getViewer().getPaletteLocation(), true)
	},
	isInCanvas : function($) {
		return this.isIn($, this.getViewer().getCanvasLocation(), true)
	},
	isIn : function(_, A, $) {
		if ($ == true)
			return _.absoluteX > A.x && _.absoluteX < A.x + A.w
				   && _.absoluteY > A.y && _.absoluteY < A.y + A.h;
		else
			return _.x > A.x && _.x < A.x + A.w && _.y > A.y
				   && _.y < A.y + A.h
	},
	getPaletteConfig : function($) {
		return this.getViewer().getPaletteConfig($.point, $.target)
	},
	findEditPartAt : function(A) {
		var _ = A.point, C = this.getContents(), B = this
			.getNodeLayer().getChildren();
		for (var D = B.length - 1; D >= 0; D--) {
			var $ = B[D];
			if (this.isIn(_, $)) {
				C = this.getEditPartByFigure($);
				return C
			}
		}
		return C
	},
	getViewer : function() {
		return this.browserListener.getViewer()
	},
	getEditor : function() {
		return this.getViewer().getEditor()
	},
	getContents : function() {
		return this.getViewer().getContents()
	},
	getModelFactory : function() {
		return this.getEditor().getModelFactory()
	},
	getCommandStack : function() {
		return this.getViewer().getEditDomain().getCommandStack()
	},
	executeCommand : function(A, $) {
		var _ = A.getCommand($);
		if (_ != null)
			this.getCommandStack().execute(_)
	},
	getDraggingLayer : function() {
		return this.getViewer().getLayer("LAYER_DRAGGING")
	},
	getNodeLayer : function() {
		return this.getViewer().getLayer("LAYER_NODE")
	},
	getConnectionLayer : function() {
		return this.getViewer().getLayer("LAYER_CONNECTION")
	},
	getHandleLayer : function() {
		return this.getViewer().getLayer("LAYER_HANDLE")
	},
	getTargetEditPart : function() {
		return this.getContents()
	},
	getEditPartByFigure : function($) {
		return $.editPart
	},
	isConnection : function() {
		return this.getViewer().getActivePalette() != null && this.getViewer().getActivePalette().isConnection == true
	},
	notConnection : function() {
		return !this.isConnection()
	},
	getSelectionManager : function() {
		return this.browserListener.getSelectionManager()
	},
	getSelectedNodes : function() {
		return this.getSelectionManager().getSelectedNodes()
	},
	hasSelectedNoneOrOne : function() {
		return this.getSelectionManager().getSelectedCount() < 2
	},
	isMultiSelect : function($) {
		return $.e.ctrlKey == true
	},
	notMultiSelect : function($) {
		return !this.isMultiSelect($)
	},
	getConnectionByConnectionId : function(_) {
		var $ = null;
		Gef.each(this.getConnectionLayer().getChildren(), function(A) {
			if (_ == A.el.id)
				$ = A
		}, this);
		return $
	},
	getNodeByNodeId : function(_) {
		var $ = null;
		Gef.each(this.getNodeLayer().getChildren(), function(A) {
			if (_ == A.el.id)
				$ = A
		}, this);
		return $
	}
});
Gef.gef.tracker.SelectionManager = Gef.extend(Object, {
	constructor : function($) {
		this.items = [];
		this.handles = {};
		this.browserListener = $
	},
	addSelectedConnection : function($) {
		this.resizeEdgeHandle = new Gef.figure.ResizeEdgeHandle();
		this.resizeEdgeHandle.edge = $.getFigure();
		this.addHandle(this.resizeEdgeHandle);
		this.resizeEdgeHandle.render();
		this.selectedConnection = $
	},
	removeSelectedConnection : function($) {
		this.resizeEdgeHandle.remove();
		this.selectedConnection = null;
		this.resizeEdgeHandle = null
	},
	addSelectedNode : function(A, $) {
		if (this.items.length == 1 && this.items[0] == A)
			return false;
		if (!$)
			this.clearAll();
		var _ = this.items.indexOf(A) != -1;
		if (_) {
			if ($) {
				this.removeSelectedNode(A, $);
				return false
			}
		} else {
			this.items.push(A);
			this.createNodeHandle(A)
		}
		return true
	},
	removeSelectedNode : function(A, $) {
		var _ = this.items.indexOf(editPart) != -1;
		if (_) {
			this.items.remove(editPart);
			this.removeNodeHandle(editPart)
		}
	},
	clearAll : function() {
		Gef.each(this.items, function($) {
			this.removeNodeHandle($)
		}, this);
		this.items = [];
		if (this.selectedConnection != null)
			this.removeSelectedConnection(this.selectedEdge);
		if (this.draggingText != null)
			this.draggingText.hide()
	},
	selectAll : function() {
		this.clearAll();
		Gef.each(this.getNodes(), function($) {
			this.addSelectedNode($.editPart, true)
		}, this)
	},
	selectIn : function($) {
		this.clearAll();
		Gef.each(this.getNodes(), function(A) {
			var _ = A, C = _.x + _.w / 2, B = _.y + _.h / 2;
			if (C > $.x && C < $.x + $.w && B > $.y && B < $.y + $.h)
				this.addSelectedNode(A.editPart, true)
		}, this)
	},
	createNodeHandle : function(A) {
		var $ = A.getModel().getId(), _ = this.handles[$];
		if (!_) {
			_ = new Gef.figure.ResizeNodeHandle();
			this.handles[$] = _;
			_.node = A.getFigure();
			this.addHandle(_);
			_.render()
		}
		return _
	},
	removeNodeHandle : function(A) {
		var $ = A.getModel().getId(), _ = this.handles[$];
		if (_ != null) {
			_.remove();
			this.handles[$] = null;
			delete this.handles[$]
		}
		return _
	},
	refreshHandles : function() {
		for (var _ in this.handles) {
			var $ = this.handles[_];
			$.refresh()
		}
		if (this.resizeEdgeHandle)
			this.resizeEdgeHandle.refresh()
	},
	addHandle : function($) {
		var _ = this.browserListener.getViewer().getLayer("LAYER_HANDLE");
		_.addChild($)
	},
	addDragging : function(_) {
		var $ = this.browserListener.getViewer().getLayer("LAYER_DRAGGING");
		$.addChild(_)
	},
	getNodes : function() {
		var $ = this.browserListener.getViewer().getLayer("LAYER_NODE");
		return $.getChildren()
	},
	getSelectedNodes : function() {
		return this.items
	},
	getSelectedCount : function() {
		return this.items.length
	},
	getSelectedConnection : function() {
		return this.selectedConnection
	},
	getDefaultSelected : function() {
		return this.browserListener.getViewer().getContents()
	},
	getCurrentSelected : function() {
		if (this.selectedConnection)
			return [this.selectedConnection];
		else if (this.items.length > 0)
			return this.items;
		else
			return [this.getDefaultSelected()]
	},
	getDraggingText : function($) {
		if (!this.draggingText) {
			this.draggingText = new Gef.figure.DraggingTextFigure($);
			this.addDragging(this.draggingText);
			this.draggingText.render()
		}
		this.draggingText.edge = $;
		this.draggingText.show();
		return this.draggingText
	}
});
Gef.gef.tracker.CreateNodeRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	DRAGGING_CREATE_NODE : "DRAGGING_CREATE_NODE",
	understandRequest : function($) {
		if ($.editType != null)
			return false;
		if ($.draggingType != null)
			return false;
		if ($.eventName == "MOUSE_DOWN" && this.status == "NONE") {
			if (this.isInPalette($.point)) {
				var _ = this.getPaletteConfig($);
				if (_ != null && _.creatable != false) {
					$.paletteConfig = _;
					$.draggingType = this.DRAGGING_CREATE_NODE;
					this.status = this.DRAGGING_CREATE_NODE
				}
			}
		} else if (($.eventName == "MOUSE_MOVE" || $.eventName == "MOUSE_UP")
				   && this.status != "NONE")
			$.draggingType = this.status;
		return $.draggingType == this.DRAGGING_CREATE_NODE
	},
	processRequest : function(_) {
		if (_.draggingType != this.DRAGGING_CREATE_NODE)
			return;
		if (_.eventName == "MOUSE_DOWN")
			this.drag(_);
		else if (_.eventName == "MOUSE_MOVE")
			this.move(_);
		else if (_.eventName == "MOUSE_UP") {
			if (this.isInCanvas(_.point)) {
				var $ = this.getDraggingRect(), A = $.name;
				_.role = {
					name : "CREATE_NODE",
					rect : {
						x : _.point.x - $.w / 2,
						y : _.point.y - $.h / 2,
						w : $.w,
						h : $.h
					},
					node : this.getModelFactory().createModel(A)
				};
				this.executeCommand(this.getTargetEditPart(), _)
			}
			this.drop(_);
			this.reset()
		}
	},
	drag : function(_) {
		var A = _.paletteConfig;
		this.getDraggingRect().name = A.text;
		var $ = A.w, C = A.h;
		if (isNaN($) || $ < 0)
			$ = 48;
		if (isNaN(C) || C < 0)
			C = 48;
		var D = $ * -1, B = C * -1;
		this.getDraggingRect().update(D, B, $, C)
	},
	move : function(A) {
		var $ = this.getDraggingRect(), _ = A.point, C = _.x - $.w / 2, B = _.y
																			- $.h / 2;
		$.moveTo(C, B)
	},
	drop : function(_) {
		var $ = this.getDraggingRect(), B = $.w * -1, A = $.h * -1;
		$.moveTo(B, A)
	}
});
Gef.gef.tracker.CreateEdgeRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	DRAGGING_CREATE_EDGE : "DRAGGING_CREATE_EDGE",
	understandRequest : function($) {
		if ($.editType != null)
			return false;
		if ($.draggingType != null)
			return;
		if (!this.isInCanvas($.point) || this.notConnection())
			return;
		if ($.eventName == "MOUSE_DOWN" && this.status == "NONE") {
			var _ = this.findEditPartAt($);
			if (_ != null && _.getClass() == "node")
				if (_.canCreateOutgo()) {
					this.temp.editPart = _;
					$.draggingType = this.DRAGGING_CREATE_EDGE;
					this.status = this.DRAGGING_CREATE_EDGE
				}
		} else if (($.eventName == "MOUSE_MOVE" || $.eventName == "MOUSE_UP") && this.status != "NONE")
			$.draggingType = this.status;
		return $.draggingType == this.DRAGGING_CREATE_EDGE
	},
	processRequest : function(A) {
		if (A.draggingType != this.DRAGGING_CREATE_EDGE)
			return;
		if (A.eventName == "MOUSE_DOWN")
			this.drag(A);
		else if (A.eventName == "MOUSE_MOVE")
			this.move(A);
		else if (A.eventName == "MOUSE_UP") {
			var _ = this.getDraggingEdge(), D = this.temp.editPart,
				B = this.findEditPartAt(A);
			if (D != B && B.getClass() == "node" && B.canCreateIncome()) {
				var $ = this.getViewer().getActivePalette().text,
					C = this.getModelFactory().createModel($);
				C.text = "to " + B.getModel().text;
				A.role = {
					name : "CREATE_EDGE",
					rect : {
						x1 : _.x1,
						y1 : _.y1,
						x2 : _.x2,
						y2 : _.y2
					},
					source : D.getModel(),
					target : B.getModel(),
					model : C
				};
				//开始节点不能直接连接判断节点 Jacky 2011 09 28
				if(A.role.source.type == 'start' && A.role.target.type == 'decision'){
					Gef.Event.trigger(Gef.Event.Alert,"开始节点不能直接连接判断节点。")
					return;
				}
				this.executeCommand(this.temp.editPart, A)
			}
			this.drop(A);
			this.reset()
		}
	},
	drag : function($) {
		this.getDraggingEdge().update(-1, -1, -1, -1)
	},
	move : function(B) {
		var A = B.point, $ = this.temp.editPart.getFigure(), C = {
			x : $.x,
			y : $.y,
			w : $.w,
			h : $.h
		}, _ = this.getDraggingEdge();
		_.updateForDragging(C, A)
	},
	drop : function($) {
		this.getDraggingEdge().moveToHide()
	}
});
Gef.gef.tracker.MoveNodeRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	DRAGGING_MOVE_NODE : "DRAGGING_MOVE_NODE",
	understandRequest : function($) {
		if ($.editType != null)
			return false;
		if ($.draggingType != null)
			return;
		if (!this.isInCanvas($.point) || this.isConnection())
			return;
		if ($.eventName == "MOUSE_DOWN" && this.status == "NONE") {
			var _ = this.findEditPartAt($);
			if (_ != null && _.getClass() == "node") {
				this.temp = {
					x : $.point.x,
					y : $.point.y,
					editPart : _
				};
				$.draggingType = this.DRAGGING_MOVE_NODE;
				this.status = this.DRAGGING_MOVE_NODE
			}
		} else if (($.eventName == "MOUSE_MOVE" || $.eventName == "MOUSE_UP") && this.status != "NONE")
			$.draggingType = this.status;
		return $.draggingType == this.DRAGGING_MOVE_NODE
	},
	processRequest : function(A) {
		if (A.draggingType != this.DRAGGING_MOVE_NODE)
			return;
		if (A.eventName == "MOUSE_DOWN") {
			if (this.notMultiSelect(A) && this.hasSelectedNoneOrOne()) {
				var B = this.findEditPartAt(A);
				this.getSelectionManager().addSelectedNode(B)
			}
			this.drag(A)
		} else if (A.eventName == "MOUSE_MOVE")
			this.move(A);
		else if (A.eventName == "MOUSE_UP") {
			var $ = this.getDraggingRect(), _ = [];
			Gef.each(this.getSelectedNodes(), function($) {
				_.push($.getModel())
			});
			if (A.point.x != this.temp.x || A.point.y != this.temp.y) {
				A.role = {
					name : "MOVE_NODE",
					nodes : _,
					dx : A.point.x - this.temp.x,
					dy : A.point.y - this.temp.y
				};
				this.executeCommand(this.getContents(), A);
				this.getSelectionManager().refreshHandles()
			} else
				A.draggingType = "DRAGGING_MOVE_NODE_WITHOUT_MOVE";
			this.drop(A);
			this.reset()
		}
	},
	drag : function($) {
		Gef.each(this.getSelectedNodes(), function(B) {
			var A = B.getFigure(), _ = A.w, D = A.h, E = A.x + $.point.x - this.temp.x,
				C = A.y + $.point.y - this.temp.y;
			this.createDraggingRects().update(_ * -1, D * -1, _, D)
		}, this);
		this.browserListener.dragging = true
	},
	move : function($) {
		Gef.each(this.getSelectedNodes(), function(C, A) {
			var _ = this.getDraggingRects(A), B = C.getFigure(),
				E = B.x + $.point.x - this.temp.x, D = B.y + $.point.y - this.temp.y;
			_.moveTo(E, D)
		}, this)
	},
	drop : function($) {
		this.removeDraggingRects();
		this.browserListener.dragging = false
	}
});
Gef.gef.tracker.MoveEdgeRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	DRAGGING_MOVE_EDGE : "DRAGGING_MOVE_EDGE",
	understandRequest : function(C) {
		if (C.editType != null)
			return false;
		if (C.draggingType != null)
			return false;
		if (!this.isInCanvas(C.point))
			return false;
		if (C.eventName == "MOUSE_DOWN" && this.status == "NONE") {
			var D = C.target;
			if (D.id.indexOf(":")) {
				var E = D.id.split(":"), A = E[0], B = E[1];
				if (B != "start" && B != "end")
					return false;
				var _ = this.getConnectionByConnectionId(A);
				if (_ == null || _ == undefined)
					return false;
				var $ = this.getSelectionManager().resizeEdgeHandle;
				if ($ == null || $ == undefined)
					return false;
				this.temp = {
					editPart : _.editPart,
					handle : $,
					direction : B
				};
				C.draggingType = this.DRAGGING_MOVE_EDGE;
				this.status = this.DRAGGING_MOVE_EDGE
			}
		} else if ((C.eventName == "MOUSE_MOVE" || C.eventName == "MOUSE_UP") && this.status != "NONE")
			C.draggingType = this.status;
		return C.draggingType == this.DRAGGING_MOVE_EDGE
	},
	processRequest : function(C) {
		if (C.draggingType != this.DRAGGING_MOVE_EDGE)
			return;
		if (C.eventName == "MOUSE_DOWN")
			this.drag(C);
		else if (C.eventName == "MOUSE_MOVE")
			this.move(C);
		else if (C.eventName == "MOUSE_UP") {
			var B = this.getDraggingEdge(), E = this.findEditPartAt(C), _ = this.temp.editPart;
			if (E.getClass() == "node") {
				var A = this.temp.direction;
				if ((A == "start" && E.canCreateOutgo())
					|| (A == "end" && E.canCreateIncome())) {
					var $ = null, D = null;
					if (A == "start") {
						$ = E.getModel();
						D = _.target.getModel()
					} else {
						$ = _.source.getModel();
						D = E.getModel()
					}
					C.role = {
						name : "MOVE_EDGE",
						rect : {
							x1 : B.x1,
							y1 : B.y1,
							x2 : B.x2,
							y2 : B.y2
						},
						source : $,
						target : D
					};
					this.executeCommand(_, C)
				}
			}
			this.drop(C);
			this.reset()
		}
	},
	drag : function(C) {
		var B = C.point, _ = this.temp.direction, D = this.temp.editPart, $ = null;
		if (_ == "start")
			$ = D.getTarget().getFigure();
		else
			$ = D.getSource().getFigure();
		var E = {
			x : $.x,
			y : $.y,
			w : $.w,
			h : $.h
		}, A = this.getDraggingEdge();
		A.updateForMove(D.getFigure(), _, B)
	},
	move : function(C) {
		var B = C.point, _ = this.temp.direction, D = this.temp.editPart, $ = null;
		if (_ == "start")
			$ = D.target.figure;
		else
			$ = D.source.figure;
		var E = {
			x : $.x,
			y : $.y,
			w : $.w,
			h : $.h
		}, A = this.getDraggingEdge();
		A.updateForMove(D.getFigure(), _, B)
	},
	drop : function($) {
		this.getDraggingEdge().moveToHide()
	}
});
Gef.gef.tracker.MoveTextRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	DRAGGING_MOVE_TEXT : "DRAGGING_MOVE_TEXT",
	understandRequest : function(B) {
		if (B.editType != null)
			return false;
		if (B.draggingType != null) {
			if (this.draggingText != null)
				this.draggingText.hide();
			return
		}
		if (!this.isInCanvas(B.point))
			return;
		if (B.eventName == "MOUSE_DOWN" && this.status == "NONE") {
			var _ = B.target, A = _.getAttribute("edgeId");
			if (A != null)
				if (_.tagName == "text" || _.tagName == "textbox") {
					var $ = this
						.getConnectionByConnectionId(A);
					if ($ == null)
						return;
					this.temp = {
						editPart : $.editPart,
						x : B.point.x,
						y : B.point.y
					};
					B.draggingType = this.DRAGGING_MOVE_TEXT;
					this.status = this.DRAGGING_MOVE_TEXT
				}
		} else if ((B.eventName == "MOUSE_MOVE" || B.eventName == "MOUSE_UP") && this.status != "NONE")
			B.draggingType = this.status;
		return B.draggingType == this.DRAGGING_MOVE_TEXT
	},
	processRequest : function(A) {
		if (A.draggingType != this.DRAGGING_MOVE_TEXT)
			return;
		if (A.eventName == "MOUSE_DOWN") {
			this.getSelectionManager().clearAll();
			this.drag(A)
		} else if (A.eventName == "MOUSE_MOVE")
			this.move(A);
		else if (A.eventName == "MOUSE_UP") {
			var C = this.temp.oldX, B = this.temp.oldY, _ = C
															+ A.point.x - this.temp.x, $ = B + A.point.y
																						   - this.temp.y;
			A.role = {
				name : "MOVE_TEXT",
				oldTextX : C,
				oldTextY : B,
				newTextX : _,
				newTextY : $,
				edge : this.temp.editPart
			};
			this.executeCommand(this.temp.editPart, A);
			this.drop(A);
			this.reset()
		}
	},
	drag : function(_) {
		var $ = this.getDraggingText();
		$.refresh();
		this.temp.oldX = $.edge.textX;
		this.temp.oldY = $.edge.textY
	},
	move : function(B) {
		var A = this.getDraggingText(), $ = B.point.x - this.temp.x,
			_ = B.point.y - this.temp.y;
		A.edge.textX = this.temp.oldX + $;
		A.edge.textY = this.temp.oldY + _;
		A.refresh()
	},
	drop : function($) {
	},
	getDraggingText : function() {
		var $ = this.temp.editPart.getFigure();
		return this.getSelectionManager().getDraggingText($)
	}
});
Gef.gef.tracker.ResizeNodeRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	DRAGGING_RESIZE_NODE : "DRAGGING_RESIZE_NODE",
	understandRequest : function(C) {
		if (C.editType != null)
			return false;
		if (C.draggingType != null)
			return false;
		if (!this.isInCanvas(C.point))
			return false;
		if (C.eventName == "MOUSE_DOWN" && this.status == "NONE") {
			var D = C.target;
			if (D.id.indexOf(":")) {
				var F = D.id.split(":"), _ = F[0], B = F[1], $ = this
					.getNodeByNodeId(_);
				if ($ == null || $ == undefined)
					return false;
				else if (!$.editPart.canResize())
					return false;
				var E = this.getSelectionManager().handles,
					A = E[$.editPart.getModel().getId()];
				if (A == null || A == undefined)
					return false;
				this.temp = {
					editPart : $.editPart,
					handle : A,
					direction : B
				};
				C.draggingType = this.DRAGGING_RESIZE_NODE;
				this.status = this.DRAGGING_RESIZE_NODE
			}
		} else if ((C.eventName == "MOUSE_MOVE" || C.eventName == "MOUSE_UP")&& this.status != "NONE")
			C.draggingType = this.status;
		return C.draggingType == this.DRAGGING_RESIZE_NODE
	},
	processRequest : function(A) {
		if (A.draggingType != this.DRAGGING_RESIZE_NODE)
			return;
		if (A.eventName == "MOUSE_DOWN")
			this.drag(A);
		else if (A.eventName == "MOUSE_MOVE")
			this.move(A);
		else if (A.eventName == "MOUSE_UP") {
			var _ = this.getDraggingRect(), B = this.temp.editPart, E = this.temp.rect.x, D = this.temp.rect.y, $ = this.temp.rect.w, C = this.temp.rect.h;
			if ($ < 0)
				$ = 5;
			if (C < 0)
				C = 5;
			A.role = {
				name : "RESIZE_NODE",
				rect : {
					x : E,
					y : D,
					w : $,
					h : C
				},
				node : B.getModel()
			};
			this.executeCommand(B, A);
			this.temp.handle.refresh();
			this.drop(A);
			this.reset()
		}
	},
	drag : function(_) {
		var A = this.temp.editPart.figure, $ = this.temp.direction;
		if ($ == "n") {
			this.temp.x = A.x + A.w / 2;
			this.temp.y = A.y
		} else if ($ == "s") {
			this.temp.x = A.x + A.w / 2;
			this.temp.y = A.y + A.h
		} else if ($ == "w") {
			this.temp.x = A.x;
			this.temp.y = A.y + A.h / 2
		} else if ($ == "e") {
			this.temp.x = A.x + A.w;
			this.temp.y = A.y + A.h / 2
		} else if ($ == "nw") {
			this.temp.x = A.x;
			this.temp.y = A.y
		} else if ($ == "ne") {
			this.temp.x = A.x + A.w;
			this.temp.y = A.y
		} else if ($ == "sw") {
			this.temp.x = A.x;
			this.temp.y = A.y + A.h
		} else if ($ == "se") {
			this.temp.x = A.x + A.w;
			this.temp.y = A.y + A.h
		}
		this.getDraggingRect().update(A.x, A.y, A.w, A.h)
	},
	move : function(G) {
		var H = G.point, F = this.temp.editPart.getFigure(), A = this.temp.direction, J = F.x, I = F.y, D = F.w, C = F.h, $ = H.x
																															  - this.temp.x, _ = H.y - this.temp.y;
		if (A == "n") {
			I = I + _;
			C = C - _
		} else if (A == "s")
			C = C + _;
		else if (A == "w") {
			J = J + $;
			D = D - $
		} else if (A == "e")
			D = D + $;
		else if (A == "nw") {
			J = J + $;
			D = D - $;
			I = I + _;
			C = C - _
		} else if (A == "ne") {
			D = D + $;
			I = I + _;
			C = C - _
		} else if (A == "sw") {
			J = J + $;
			D = D - $;
			C = C + _
		} else if (A == "se") {
			D = D + $;
			C = C + _
		}
		var B = {
			x : J,
			y : I,
			w : D,
			h : C
		};
		this.temp.rect = B;
		var E = this.getDraggingRect();
		E.update(B.x, B.y, B.w, B.h)
	},
	drop : function($) {
		this.getDraggingRect().update(-1, -1, 1, 1)
	}
});
Gef.gef.tracker.ResizeEdgeRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	DRAGGING_RESIZE_EDGE : "DRAGGING_RESIZE_EDGE",
	understandRequest : function(J) {
		if (J.editType != null)
			return false;
		if (J.draggingType != null)
			return;
		if (!this.isInCanvas(J.point))
			return;
		if (J.eventName == "MOUSE_DOWN" && this.status == "NONE") {
			var K = J.target, F = K.id;
			if (F != null && F.indexOf(":middle:") != -1) {
				var I = F.substring(0, F.indexOf(":middle:")), _ = this
					.getConnectionByConnectionId(I);
				if (_ == null || _ == undefined)
					return;
				var $ = F.substring(F.indexOf(":middle:")
									+ ":middle:".length).split(","), C = parseInt(
					$[0], 10), G = parseInt($[1], 10), D = this
					.getSelectionManager().resizeEdgeHandle, A = [];
				Gef.each(_.innerPoints, function($) {
					A.push([$[0], $[1]])
				});
				var H = null, E = null, B = null;
				if (C == G) {
					H = _.innerPoints[C];
					if (C == 0)
						E = [_.x1, _.y1];
					else
						E = _.innerPoints[C - 1];
					if (G == _.innerPoints.length - 1)
						B = [_.x2, _.y2];
					else
						B = _.innerPoints[C + 1]
				} else {
					if (C == -1)
						E = [_.x1, _.y1];
					else
						E = _.innerPoints[C];
					if (G >= _.innerPoints.length)
						B = [_.x2, _.y2];
					else
						B = _.innerPoints[G];
					H = [(E[0] + B[0]) / 2, (E[1] + B[1]) / 2];
					_.innerPoints.splice(C + 1, 0, H);
					D.modify()
				}
				this.temp = {
					editPart : _.editPart,
					point : H,
					x : H[0],
					y : H[1],
					oldX : J.point.x,
					oldY : J.point.y,
					prevIndex : C,
					nextIndex : G,
					prev : E,
					next : B,
					oldInnerPoints : A
				};
				J.draggingType = this.DRAGGING_RESIZE_EDGE;
				this.status = this.DRAGGING_RESIZE_EDGE
			}
		} else if ((J.eventName == "MOUSE_MOVE" || J.eventName == "MOUSE_UP") && this.status != "NONE")
			J.draggingType = this.status;
		return J.draggingType == this.DRAGGING_RESIZE_EDGE
	},
	processRequest : function($) {
		if ($.draggingType != this.DRAGGING_RESIZE_EDGE)
			return;
		if ($.eventName == "MOUSE_DOWN")
			this.drag($);
		else if ($.eventName == "MOUSE_MOVE")
			this.move($);
		else if ($.eventName == "MOUSE_UP") {
			var _ = this.temp.editPart;
			if (this.isSameLine($.point.x, $.point.y,
								this.temp.prev[0], this.temp.prev[1],
								this.temp.next[0], this.temp.next[1]))
				_.getFigure().innerPoints
				 .splice(this.temp.nextIndex, 1);
			$.role = {
				name : "RESIZE_EDGE",
				rect : {
					x : _.figure.x,
					y : _.figure.y,
					w : _.figure.w,
					h : _.figure.h
				},
				oldInnerPoints : this.temp.oldInnerPoints,
				newInnerPoints : _.getFigure().innerPoints
			};
			this.executeCommand(_, $);
			var A = this.getSelectionManager().resizeEdgeHandle;
			A.modify();
			this.drop($);
			this.reset()
		}
	},
	drag : function($) {
	},
	move : function(A) {
		var $ = A.point.x - this.temp.oldX, _ = A.point.y - this.temp.oldY;
		this.temp.point[0] = this.temp.x + $;
		this.temp.point[1] = this.temp.y + _;
		var B = this.getSelectionManager().resizeEdgeHandle;
		B.modify()
	},
	drop : function($) {
	},
	isSameLine : function(J, A, K, C, G, D) {
		var E = new Geom.Line(K, C, G, D), B = 0;
		if (C == D)
			B = Math.abs(A - C);
		else {
			var I = E.getK(), _ = E.getD(), $ = -1 / I,
				M = A - $ * J, H = (_ - M) / ($ - I), F = I * H + _;
			B = Math.sqrt((J - H) * (J - H) + (A - F) * (A - F))
		}
		return B < 10
	}
});
Gef.gef.tracker.MarqueeRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	DRAGGING_MARQUEE : "DRAGGING_MARQUEE",
	understandRequest : function(_) {
		if (_.editType != null)
			return false;
		if (_.draggingType != null)
			return;
		if (!this.isInCanvas(_.point))
			return;
		if (_.eventName == "MOUSE_DOWN" && this.status == "NONE") {
			if (this.isInCanvas(_.point)) {
				var $ = _.target;
				if ((Gef.isVml && $.tagName == "DIV") || (Gef.isSvg && $.tagName == "svg")) {
					_.draggingType = this.DRAGGING_MARQUEE;
					this.status = this.DRAGGING_MARQUEE
				}
			}
		} else if ((_.eventName == "MOUSE_MOVE" || _.eventName == "MOUSE_UP") && this.status != "NONE")
			_.draggingType = this.status;
		return _.draggingType == this.DRAGGING_MARQUEE
	},
	processRequest : function(_) {
		if (_.draggingType != this.DRAGGING_MARQUEE)
			return;
		if (_.eventName == "MOUSE_DOWN")
			this.drag(_);
		else if (_.eventName == "MOUSE_MOVE")
			this.move(_);
		else if (_.eventName == "MOUSE_UP") {
			var A = this.getDraggingRect(), $ = {
				x : _.point.x < A.x ? _.point.x : A.x,
				y : _.point.y < A.y ? _.point.y : A.y,
				w : A.w,
				h : A.h
			};
			this.getSelectionManager().selectIn($);
			this.drop(_);
			this.reset()
		}
	},
	drag : function(_) {
		var $ = _.point;
		this.getDraggingRect().update($.x, $.y, 0, 0)
	},
	move : function(A) {
		var $ = this.getDraggingRect(), _ = A.point;
		$.update($.x, $.y, _.x - $.x, _.y - $.y)
	},
	drop : function($) {
		this.getDraggingRect().update(-90, -90, 100, 60)
	}
});
Gef.gef.tracker.DirectEditRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	understandRequest : function(_) {
		if (this.status != "NONE")
			_.editType = this.status;
		if (this.isInCanvas(_.point) && _.eventName == "DBL_CLICK")
			if (_.target.tagName == "text"
				|| _.target.tagName == "textbox") {
				_.editType = "EDIT_START";
				this.status = "EDIT_START"
			}
		if (_.eventName == "MOUSE_DOWN" && _.target.tagName != "INPUT")
			if (this.status == "ALREADY_START_EDIT") {
				_.editType = "EDIT_COMPLETE";
				this.status = "EDIT_COMPLETE"
			}
		if (_.eventName == "KEY_DOWN") {
			var $ = _.e.keyCode;
			if ($ == 10 || $ == 13) {
				_.editType = "EDIT_COMPLETE";
				this.status = "EDIT_COMPLETE"
			}
			if ($ == 27) {
				_.editType = "EDIT_CANCEL";
				this.status = "EDIT_CANCEL"
			}
		}
		return _.editType == "EDIT_START"
			   || _.editType == "ALREADY_START_EDIT"
			   || _.editType == "EDIT_CANCEL"
			   || _.editType == "EDIT_COMPLETE"
	},
	processRequest : function($) {
		if (!$.editType)
			return;
		if ($.editType == "EDIT_START")
			this.startEdit($);
		else if ($.editType == "EDIT_COMPLETE")
			this.completeEdit($);
		else if ($.editType == "EDIT_CANCEL")
			this.cancelEdit($)
	},
	startEdit : function(A) {
		var B = this.findEditPartAt(A);
		if (B.getClass() == "node") {
			if (B.getFigure().updateAndShowText != null) {
				this.getTextEditor().showForNode(B.getFigure());
				this.temp.editPart = B;
				this.status = "ALREADY_START_EDIT"
			} else
				this.status = "NONE"
		} else if (this.isText(A.target)) {
			var _ = A.target.getAttribute("edgeId"), $ = this.getConnectionByConnectionId(_);
			if($ != null){//JACKY -------------
				this.getTextEditor().showForEdge($);
				this.temp.editPart = $.editPart;
			}
			this.status = "ALREADY_START_EDIT"
		}
	},
	completeEdit : function(A) {
		if (!this.temp.editPart)
			return;
		var B = this.temp.editPart, $ = this.getTextEditor().getValue().trim();
		if ($ != B.getModel().name) {
			A.role = {
				name : "EDIT_TEXT",
				text : $
			};
			this.executeCommand(B, A)
		}
		this.getTextEditor().hide();
		var _ = this.getSelectionManager().draggingText;
		if (_)
			_.refresh();
		this.reset()
	},
	cancelEdit : function($) {
		this.getTextEditor().hide();
		this.reset()
	},
	isText : function($) {
		return (Gef.isVml && $.tagName == "textbox")
			   || (Gef.isSvg && $.tagName == "text")
	},
	getTextEditor : function() {
		var A = this.browserListener.getViewer().getCanvasLocation();
		var _ = A.x, $ = A.y;
		if(typeof Gef.Editor.EditorInterface.editor != "undefined")
		{
			var B = this.browserListener.getViewer().getPaletteLocation();
			var C = this.browserListener.getViewer().getCanvasClientLocation();
			_ = Gef.Editor.EditorInterface.editor.offsetLeft + B.w + 4;
			$ = Gef.Editor.EditorInterface.editor.offsetTop + (Gef.Editor.EditorInterface.editor.offsetHeight - C.ch - C.st);
		}
		if (!this.textEditor) {
			this.textEditor = new Gef.figure.TextEditor(_, $)
		}
		this.textEditor.baseX = _;
		this.textEditor.baseY = $;
		this.textEditor.show();
		return this.textEditor
	}
});
Gef.gef.tracker.RemoveRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	understandRequest : function($) {
		if ($.editType != null)
			return false;
		if ($.eventName != "KEY_DOWN")
			return;
		$.removeType = "REMOVE";
		return $.removeType == "REMOVE"
	},
	processRequest : function(_) {
		if (_.removeType != "REMOVE")
			return;
		if (_.eventName == "KEY_DOWN") {
			var $ = _.e.keyCode;
			if ($ == 46) {
				_.removeType = "REMOVE";
				this.status = "REMOVE";
				this.removeAll(_)
			}
			if (_.e.ctrlKey && $ == 65) {
				_.removeType = "SELECT_ALL";
				this.status = "SELECT_ALL";
				this.selectAllNodes(_)
			}
		}
	},
	removeAll : function(C) {
		try {
			var $ = this.getSelectionManager(), A = $.selectedConnection, B = $.items;
			if (A != null) {
				C.role = {
					name : "REMOVE_EDGE"
				};
				this.executeCommand(A, C);
				$.removeSelectedConnection()
			} else if (B.length > 0) {
				C.role = {
					name : "REMOVE_NODES",
					nodes : B
				};
				this.executeCommand(
					this.browserListener.graphicalViewer
						.getContents(), C);
				$.clearAll()
			}
		} catch (_) {
			console.error(_)
		}
	},
	selectAllNodes : function($) {
		this.getSelectionManager().selectAll()
	}
});
Gef.gef.tracker.SelectionRequestTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	understandRequest : function($) {
		if ($.editType != null)
			return false;
		if ($.draggingType != null)
			return false;
		if ($.eventName != "MOUSE_UP" || !this.isInCanvas($.point))
			return false;
		if (this.browserListener.dragging == true)
			return false;
		$.selectType = "SELECT";
		return $.selectType == "SELECT"
	},
	processRequest : function(A) {
		if (A.selectType != "SELECT")
			return;
		var B = this.findEditPartAt(A);
		if (B.getClass() == "process")
			;
		else if (B.getClass() == "node") {
			var _ = this.addSelected(B, this.isMultiSelect(A));
			if (_) {
				var $ = this.createNodeHandle(B);
				$.refresh()
			}
		} else if (B.getClass() == "connection") {
			this.clearAll();
			this.addSelectedEdge(B)
		}
	},
	addSelectedEdge : function($) {
		this.getSelectionManager().addSelectedConnection($)
	},
	removeSelectedEdge : function($) {
		this.getSelectionManager().removeSelectedConnection($)
	},
	addSelected : function(_, $) {
		return this.getSelectionManager().addSelectedNode(_, $)
	},
	removeSelected : function(_, $) {
		this.getSelectionManager().removeSelectedNode(_, $)
	},
	clearAll : function() {
		this.getSelectionManager().clearAll()
	},
	selectAll : function() {
		this.getSelectionManager().selectAll()
	},
	selectIn : function($) {
		this.getSelectionManager().selectIn($)
	},
	createNodeHandle : function($) {
		return this.getSelectionManager().createNodeHandle($)
	},
	removeNodeHandle : function($) {
		return this.getSelectionManager.removeNodeHandle($)
	},
	refreshHandles : function() {
		this.getSelectionManager.refreshHandles()
	},
	findEditPartAt : function(_) {
		var $ = _.point, A = this.getContents();
		Gef.each(this.getNodeLayer().getChildren(), function(_) {
			if (this.isIn($, _)) {
				A = this.getEditPartByFigure(_);
				return false
			}
		}, this);
		Gef.each(this.getConnectionLayer().getChildren(), function($) {
			if (_.target.id == $.el.id) {
				A = this.getEditPartByFigure($);
				return false
			}
		}, this);
		return A
	}
});
Gef.gef.tracker.SelectionListener = Gef.extend(Object, {
	selectionChanged : Gef.emptyFn
});
Gef.gef.tracker.SelectionListenerTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	understandRequest : function($) {
		return $.eventName == "MOUSE_UP" || $.eventName == "KEY_DOWN"
	},
	processRequest : function(B) {
		var $ = this.getSelectionManager();
		if (!this.previousSelected)
			this.previousSelected = [$.getDefaultSelected()];
		var A = $.getCurrentSelected(), _ = $.getDefaultSelected(), C = false;
		if (this.previousSelected.length == A.length) {
			for (var D = 0; D < A.length; D++)
				if (A[D] != this.previousSelected[D]) {
					C = true;
					break
				}
		} else
			C = true;
		if (C == true) {
			Gef.each(this.getSelectionListeners(), function($) {
				$.selectionChanged(A, this.previousSelected, _)
			});
			this.previousSelected = A
		}
	},
	getSelectionListeners : function() {
		if (!this.selectionListeners)
			this.selectionListeners = [];
		return this.selectionListeners
	},
	addSelectionListener : function($) {
		this.getSelectionListeners().push($)
	}
});
Gef.gef.tracker.DefaultSelectionListener = Gef.extend(Gef.gef.tracker.SelectionListener, {
	selectionChanged : function(A, $, _) {
		if (A.length == 1) {
			var B = A[0];
			if (B == _)
				this.selectDefault(_);
			else if (B.getClass() == "node")
				this.selectNode(B);
			else
				this.selectConnection(B)
		} else
			this.selectDefault(_)
	},
	selectNode : Gef.emptyFn,
	selectConnection : Gef.emptyFn,
	selectDefault : Gef.emptyFn
});
Gef.gef.tracker.ToolTracker = Gef.extend(Gef.gef.tracker.AbstractRequestTracker, {
	isTool : function(_) {
		var $ = false, A = null;
		Gef.each(this.getSelectedNodes(), function(B) {
			Gef.each(B.getFigure().getTools(), function(B) {
				if (B.isClicked(_)) {
					$ = true;
					A = B;
					return false
				}
				if ($ == true)
					return false
			})
		});
		if ($ == true)
			this.selectedTool = A;
		return $
	},
	understandRequest : function($) {
		if ($.editType != null)
			return false;
		if ($.draggingType != null)
			return false;
		if ($.eventName == "MOUSE_DOWN" && this.status == "NONE") {
			if (this.isTool($)) {
				this.status = "TOOL_SELECTED";
				this.draggingType = this.status;
				return true
			}
		} else if ($.eventName == "MOUSE_MOVE") {
			if (this.status == "TOOL_SELECTED") {
				this.status = "TOOL_MOVE";
				this.draggingType = this.status;
				return true
			} else if (this.status == "TOOL_MOVE")
				return true
		} else if ($.eventName == "MOUSE_UP")
			if (this.status == "TOOL_MOVE") {
				this.status = "TOOL_DROP";
				this.draggingType = this.status;
				return true
			} else if (this.status == "TOOL_DROP")
				return true;
		return false
	},
	processRequest : function($) {
		if (!this.status)
			return;
		if (this.status == "TOOL_SELECTED")
			this.drag($);
		else if (this.status == "TOOL_MOVE")
			this.move($);
		else if (this.status == "TOOL_DROP")
			this.drop($)
	},
	drag : function($) {
		this.selectedTool.drag(this)
	},
	move : function($) {
		this.selectedTool.move(this, $)
	},
	drop : function($) {
		this.selectedTool.drop(this, $);
		this.reset()
	}
});


Gef.ns("Gef.simple");
Gef.simple.SimpleEditPartFactory = Gef.extend(Gef.gef.EditPartFactory, {
	createEditPart : function($) {
		switch ($) {
			case "process" :
				return new Gef.simple.editpart.ProcessEditPart($);
			case "start" :
				return new Gef.simple.editpart.StartEditPart($);
			case "end" :
				return new Gef.simple.editpart.EndEditPart($);
			case "endCancel" ://新增的end-cancel节点
				return new Gef.simple.editpart.EndCancelEditPart($);
			case "task" :
				return new Gef.simple.editpart.TaskEditPart($);
			case "state" : //新增的节点
				return new Gef.simple.editpart.StateEditPart($);
			case "fork" : //新增的节点 : fork
				return new Gef.simple.editpart.ForkEditPart($);
			case "join" : //新增的节点 : join
				return new Gef.simple.editpart.JoinEditPart($);
			case "decision" : //新增的节点 : decision
				return new Gef.simple.editpart.DecisionEditPart($);
			case "transition" :
				return new Gef.simple.editpart.TransitionEditPart($);
			case "sign":
				return new Gef.simple.editpart.CountersignEditPart($);
			case "sub":
				return new Gef.simple.editpart.SubprocessEditPart($);
			default :
				return null
		}
	}
});
Gef.simple.SimpleModelFactory = Gef.extend(Gef.gef.ModelFactory, {
	getId : function($)
	{
		var editor          = Gef.activeEditor;
		var graphicalViewer = editor.getGraphicalViewer();
		var contents        = graphicalViewer.getContents();
		var elemnets        = contents.getModel().children;
		if (this.map == null || this.map == undefined)
		{
			var startNumber    = 0;
			var stateNumber    = 0;
			var taskNumber     = 0;
			var decisionNumber = 0;
			var forkNumber     = 0;
			var joinNumber     = 0;
			var endNumber      = 0;
			for (var i = 0; i < elemnets.length; i++)
			{
				var element = elemnets[i];
				var type    = element.type;
				if ("start" == type)
				{
					startNumber++;
				}
				else if ("state" == type)
				{
					stateNumber++;
				}
				else if ("task" == type)
				{
					taskNumber++;
				}
				else if ("decision" == type)
				{
					decisionNumber++;
				}
				else if ("fork" == type)
				{
					forkNumber++;
				}
				else if ("join" == type)
				{
					joinNumber++;
				}
				else if ("end" == type)
				{
					endNumber++;
				}
			}
			this.map             = {};
			this.map['start']    = startNumber;
			this.map['state']    = stateNumber;
			this.map['task']     = taskNumber;
			this.map['decision'] = decisionNumber;
			this.map['fork']     = forkNumber;
			this.map['join']     = joinNumber;
			this.map['end']      = endNumber;
		}

		if ($ == "transition")
		{
			if (this.map[$] == null || this.map[$] == undefined)
				this.map[$] = 1;
			else
				this.map[$]++;
			return $ + "_" + this.map[$];
		}
		else
		{
			if (this.map[$] == null || this.map[$] == undefined)
				this.map[$] = 1;
			else
			{
				if (this.map[$] <= elemnets.length)
					this.map[$]++;
			}

			for (var i = 1; i <= this.map[$]; i++)
			{
				var tmp    = $ + "_" + i;
				var isfind = false;
				for (var j = 0; j < elemnets.length; j++)
				{
					if (elemnets[j].text == tmp)
					{
						isfind = true;
						break;
					}
				}
				if (!isfind)
				{
					return tmp;
				}
			}
		}
	},
	reset : function() {
		delete this.map;
		this.map = {}
	},
	createModel : function(_) {
		var $ = this.getId(_);
		switch (_) {
			case "process" :
				return new Gef.simple.model.ProcessModel({
															 id : $,
															 text : $
														 });
			case "start" :
				return new Gef.simple.model.StartModel({
														   id : $,
														   text : "开始"
													   });
			case "state" :
				return new Gef.simple.model.StateModel({
														   id : $,
														   text : $
													   });
			case "fork" : //fork
				return new Gef.simple.model.ForkModel({
														  id : $,
														  text : $
													  });
			case "join" :
				return new Gef.simple.model.JoinModel({
														  id : $,
														  text : $
													  });
			case "decision" :
				return new Gef.simple.model.DecisionModel({
															  id : $,
															  text : $
														  });
			case "end" :
				return new Gef.simple.model.EndModel({
														 id : $,
														 text : "结束"
													 });
			case "endCancel" :
				return new Gef.simple.model.EndCancelModel({
															   id : $,
															   text : "中止"
														   });
			case "task" :
				return new Gef.simple.model.TaskModel({
														  id : $,
														  text : $
													  });
			case "transition" :
				return new Gef.simple.model.TransitionModel({
																id : $,
																text : $
															});
			case "sign":
				return new Gef.simple.model.CountersignModel({
																 id : $,
																 text : $
															 });
			case "sub":
				return new Gef.simple.model.SubprocessModel({
																id : $,
																text : $
															});
			default :
				return null
		}
	}
});
Gef.simple.SimplePaletteHelper = Gef.extend(Gef.gef.support.PaletteHelper, {
	constructor : function($) {
		this.editor = $
	},
	createSource : function() {
		var $ = this;
		return {
			title : "palette",
			buttons : [{
				text : "export",
				handler : function() {
					alert($.editor.serial())
				}
			}, {
				text : "clear",
				handler : function() {
					$.editor.clear()
				}
			}, {
				text : "reset",
				handler : function() {
					$.editor.reset()
				}
			}],
			groups : [{
				title : "Operations",
				items : [{
					text : "Select",
					iconCls : "gef-tool-select",
					creatable : false
				}, {
					text : "Marquee",
					iconCls : "gef-tool-marquee",
					creatable : false
				}]
			}, {
				title : "Activities",
				items : [{
					text : "transition",
					iconCls : "gef-tool-transition",
					creatable : false,
					isConnection : true
				}, {
					text : "start",
					iconCls : "gef-tool-start",
					w : 48,
					h : 48
				}, {
					text : "state",
					iconCls : "gef-tool-state",
					w : 90,
					h : 50
				}, {
					text : "join",
					iconCls : "gef-tool-join",
					w : 48,
					h : 48
				},{
					text : "fork",
					iconCls : "gef-tool-fork",
					w : 48,
					h : 48
				}, {
					text : "decision",
					iconCls : "gef-tool-decision",
					w : 48,
					h : 48
				}, {
					text : "end",
					iconCls : "gef-tool-end",
					w : 48,
					h : 48
				}, {
					text : "endCancel",
					iconCls : "gef-tool-end-cancel",
					w : 48,
					h : 48
				}, {
					text : "task",
					iconCls : "gef-tool-task",
					w : 90,
					h : 50
				},{
					text : "sign",
					iconCls : "gef-tool-fork",
					w : 90,
					h : 50
				},{
					text : "sub",
					iconCls : "gef-tool-fork",
					w : 90,
					h : 50
				}]
			}]
		}
	},
	getSource : function() {
		if (!this.source)
			this.source = this.createSource();
		return this.source
	},
	render : function(O) {
		var C = this.getSource(), K = document.createElement("div");
		K.className = "gef-drag-handle";
		O.appendChild(K);
		var $ = document.createElement("span");
		K.appendChild($);
		$.unselectable = "on";
		$.innerHTML = C.title;
		var L = this;
		for (var F = 0; F < C.buttons.length; F++) {
			var I = C.buttons[F], _ = document.createElement("a");
			_.href = "javascript:void(0);";
			_.onclick = I.handler;
			_.innerHTML = "|" + I.text + "|";
			$.appendChild(_)
		}
		var A = document.createElement("ul");
		O.appendChild(A);
		for (F = 0; F < C.groups.length; F++) {
			var M = C.groups[F], D = document.createElement("li");
			D.className = "gef-palette-bar";
			A.appendChild(D);
			var H = document.createElement("div");
			H.unselectable = "on";
			H.innerHTML = M.title;
			D.appendChild(H);
			var N = document.createElement("ul");
			D.appendChild(N);
			for (var E = 0; E < M.items.length; E++) {
				var J = M.items[E], G = document.createElement("li");
				G.id = J.text;
				G.className = "gef-palette-item";
				N.appendChild(G);
				var B = document.createElement("span");
				B.innerHTML = J.text;
				B.className = J.iconCls;
				B.unselectable = "on";
				G.appendChild(B)
			}
		}
	},
	getActivePalette : function() {
		return this.activePalette
	},
	setActivePalette : function($) {
		this.activePalette = $
	},
	getPaletteConfig : function(D, _) {
		var $ = _.parentNode.id;
		if (!$)
			return null;
		var B = this.getSource(), E = null;
		Gef.each(B.groups, function(_) {
			Gef.each(_.items, function(_) {
				if (_.text == $) {
					E = _;
					return false
				}
			});
			if (E != null)
				return false
		});
		if (!E)
			return null;
		var A = null;
		if (this.getActivePalette()) {
			var C = this.getActivePalette().text;
			A = document.getElementById(C);
			A.style.background = "white"
		}
		this.setActivePalette(E);
		A = document.getElementById($);
		A.style.background = "#CCCCCC";
		if (E.creatable == false)
			return null;
		return E
	}
});
Gef.simple.SimpleEditor = Gef.extend(Gef.gef.support.DefaultGraphicalEditorWithPalette, {
	constructor : function() {
		this.modelFactory = new Gef.simple.SimpleModelFactory();
		this.editPartFactory = new Gef.simple.SimpleEditPartFactory();
		Gef.simple.SimpleEditor.superclass.constructor.call(this)
	},
	getPaletteHelper : function() {
		if (!this.paletteHelper)
			this.paletteHelper = new Gef.simple.SimplePaletteHelper(this);
		return this.paletteHelper
	},
	serial : function() {
		var $ = this.getGraphicalViewer().getContents().getModel(),
			_ = new Gef.simple.xml.SimpleSerializer($),
			A = _.serialize();
		return A
	},
	//逆向生成流程图的方法
	deserial : function() {
	},

	clear : function() {
		var D = this.getGraphicalViewer(), C = D.getContents(),
			B = D.getBrowserListener(),
			_ = D.getEditDomain().getCommandStack(),
			$ = B.getSelectionManager();
		$.selectAll();
		var A = C.getRemoveNodesCommand({
											role : {
												nodes : $.getSelectedNodes()
											}
										});
		_.execute(A);
		$.clearAll();
		this.editDomain.editPartRegistry = []
	},
	reset : function() {
		this.clear();
		var A = this.getGraphicalViewer(), $ = A.getEditDomain().getCommandStack();
		$.flush();
		this.getModelFactory().reset();
		var _ = A.getContents();
		_.text = "untitled";
		_.key = null;
		_.description = null
	},
});
Gef.simple.SimpleEditorInput = Gef.extend(Gef.ui.EditorInput, {
	constructor : function($) {
		if (!$)
			$ = "process";
		this.simpleModel = $
	},
	readXml : function($) {
		var _ = new Gef.simple.xml.SimpleDeserializer($);
		this.simpleModel = _.decode()
	},
	getName : function() {
		return this.simpleModel.name
	},
	getObject : function() {
		return this.simpleModel
	}
});


Gef.ns("Gef.simple.editpart");
Gef.simple.editpart.ProcessEditPart = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		return new Gef.simple.figure.ProcessFigure()
	},
	getClass : function() {
		return "process"
	},
	canCreate : function($) {
		var _ = true;
		if ($.getType() == "start"){
			Gef.each(this.children, function($) {
				if ($.getModel().type == "start") {
					Gef.Event.trigger(Gef.Event.Alert,"一个流程只能有一个开始节点")
					_ = false;
					return false
				}
			});
		}else if ($.getType() == "end"){
			Gef.each(this.children, function($) {
				if ($.getModel().type == "end") {
					Gef.Event.trigger(Gef.Event.Alert,"一个流程图中只允许有一个结束节点！")
					_ = false;
					return false
				}
			});
		}else if ($.getType() == "endCancel"){
			Gef.each(this.children, function($) {
				if ($.getModel().type == "endCancel") {
					Gef.Event.trigger(Gef.Event.Alert,"一个流程图中只允许有一个中止节点！")
					_ = false;
					return false
				}
			});
		}
		return _;
	}
});
//新增的节点入口：开始
Gef.simple.editpart.StartEditPart = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var _ = new Gef.simple.figure.StartFigure({
													  x : this.model.x,
													  y : this.model.y,
													  name : this.model.text
												  });
		_.editPart = this;
		return _
	},
	canCreateOutgo : function() {
		if (this.getSourceConnections().length == 0)
			return true;
		else {
			Gef.Event.trigger(Gef.Event.Alert,"开始节点只能有一个出边。")
			return false
		}
	},
	canCreateIncome : function() {
		Gef.Event.trigger(Gef.Event.Alert,"不能指向开始节点。")
		return false
	},
	canResize : function() {
		return false
	}
});
//新增的节点入口：结束
Gef.simple.editpart.EndEditPart = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var j=0;
		for(var i=0;  i<this.parent.children.length; i++){
			if(this.parent.children[i].model.type == 'end'){
				j++;
				if(j>=2){
					Gef.Event.trigger(Gef.Event.Alert,"一个流程图中只允许有一个结束节点！")
					return this.getModel();
				}
			}
		}
		if(j<=1){
			var _ = new Gef.simple.figure.EndFigure({
														x : this.model.x,
														y : this.model.y,
														name : this.model.text
													});
			_.editPart = this;
			return _;
		}
	},
	canCreateOutgo : function() {
		Gef.Event.trigger(Gef.Event.Alert,"结束节点不能有任何出边")
		return false
	},
	canResize : function() {
		return false
	}
});
//新增的节点入口：中止
Gef.simple.editpart.EndCancelEditPart = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var j=0;
		for(var i=0;  i<this.parent.children.length; i++){
			if(this.parent.children[i].model.type == 'endCancel'){
				j++;
				if(j>=2){
					Gef.Event.trigger(Gef.Event.Alert,"一个流程图中只允许有一个中止节点！")
					return this.getModel();
				}
			}
		}
		if(j<=1){
			var _ = new Gef.simple.figure.EndCancelFigure({
															  x : this.model.x,
															  y : this.model.y,
															  name : this.model.text
														  });
			_.editPart = this;
			return _;
		}
	},
	canCreateOutgo : function() {
		Gef.Event.trigger(Gef.Event.Alert,"中止节点不能有任何出边")
		return false
	},
	canResize : function() {
		return false
	}
});
//新增的节点入口：任务
Gef.simple.editpart.TaskEditPart = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var _ = new Gef.simple.figure.TaskFigure({
													 x : this.model.x,
													 y : this.model.y,
													 name : this.model.text
												 });
		_.editPart = this;
		return _
	}
});
//新增的节点入口：状态
Gef.simple.editpart.StateEditPart = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var _ = new Gef.simple.figure.StateFigure({
													  x : this.model.x,
													  y : this.model.y,
													  name : this.model.text
												  });
		_.editPart = this;
		return _
	}
});
//新增的节点入口: 分支
Gef.simple.editpart.ForkEditPart = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var _ = new Gef.simple.figure.ForkFigure({
													 x : this.model.x,
													 y : this.model.y,
													 name : this.model.text
												 });
		_.editPart = this;
		return _
	},
	canCreateIncome : function() {
		if(this.getTargetConnections().length == 0){
			return true;
		}else{
			Gef.Event.trigger(Gef.Event.Alert,"分散节点只能有一个入边。")
			return false
		}
	},
	canResize : function() {
		return false
	}
});
//新增的节点入口: 合并
Gef.simple.editpart.JoinEditPart = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var _ = new Gef.simple.figure.JoinFigure({
													 x : this.model.x,
													 y : this.model.y,
													 name : this.model.text
												 });
		_.editPart = this;
		return _
	},
	canCreateOutgo : function() {
		if (this.getSourceConnections().length == 0)
			return true;
		else {
			Gef.Event.trigger(Gef.Event.Alert,"合并节点只能有一个出边。")
			return false
		}
	},
	canResize : function() {
		return false
	}
});
//新增的节点入口: 判断
Gef.simple.editpart.DecisionEditPart = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var _ = new Gef.simple.figure.DecisionFigure({
														 x : this.model.x,
														 y : this.model.y,
														 name : this.model.text
													 });
		_.editPart = this;
		return _
	},
	canCreateIncome : function() {
		if(this.getTargetConnections().length == 0){
			return true;
		}else{
			Gef.Event.trigger(Gef.Event.Alert,"判断节点只能有一个入边。")
			return false
		}
	},
	canCreateOutgo : function() {
		if (this.getSourceConnections().length < 2)
			return true;
		else {
			Gef.Event.trigger(Gef.Event.Alert,"判断节点最多有两个出边。")
			return false
		}
	},
	canResize : function() {
		return false
	}
});
//新增的节点入口：会签
Gef.simple.editpart.CountersignEditPart  = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var _ = new Gef.simple.figure.CountersignFigure({
															x : this.model.x,
															y : this.model.y,
															name : this.model.text
														});
		_.editPart = this;
		return _
	},
	canResize : function() {
		return true
	}
});
//新增的节点入口：子流程
Gef.simple.editpart.SubprocessEditPart  = Gef.extend(Gef.gef.editparts.NodeEditPart, {
	createFigure : function() {
		var _ = new Gef.simple.figure.SubprocessFigure({
														   x : this.model.x,
														   y : this.model.y,
														   name : this.model.text
													   });
		_.editPart = this;
		return _
	},
	canResize : function() {
		return true
	}
});
//新增的节点入口：节点连线
Gef.simple.editpart.TransitionEditPart = Gef.extend(Gef.gef.editparts.ConnectionEditPart, {
	createFigure : function() {
		var $ = this.getModel(),
			_ = new Gef.simple.figure.TransitionFigure(this.getSource().getFigure(), this.getTarget().getFigure());
		_.innerPoints = $.innerPoints;
		_.name = $.text;
		_.textX = $.textX;
		_.textY = $.textY;
		_.editPart = this;
		return _
	}
});


Gef.ns("Gef.simple.model");
Gef.simple.model.ProcessModel = Gef.extend(Gef.model.NodeModel, {
	type : "process"
});
//新增的节点模型：开始
Gef.simple.model.StartModel = Gef.extend(Gef.model.NodeModel, {
	type : "start"
});
//新增的节点模型：结束
Gef.simple.model.EndModel = Gef.extend(Gef.model.NodeModel, {
	type : "end"
});
//新增的节点模型：任务
Gef.simple.model.TaskModel = Gef.extend(Gef.model.NodeModel, {
	type : "task"
});
//新增的节点模型：状态
Gef.simple.model.StateModel = Gef.extend(Gef.model.NodeModel, {
	type : "state"
});
//新增的节点模型：分支
Gef.simple.model.ForkModel = Gef.extend(Gef.model.NodeModel, {
	type : "fork"
});
//新增的节点模型：合并
Gef.simple.model.JoinModel = Gef.extend(Gef.model.NodeModel, {
	type : "join"
});
//新增的节点模型：判断
Gef.simple.model.DecisionModel = Gef.extend(Gef.model.NodeModel, {
	type : "decision"
});
//新增的节点模型：会签
Gef.simple.model.CountersignModel = Gef.extend(Gef.model.NodeModel, {
	type : "sign"
});
//新增的节点模型：子流程
Gef.simple.model.SubprocessModel = Gef.extend(Gef.model.NodeModel, {
	type : "sub"
});
//新增的节点模型：节点连线
Gef.simple.model.TransitionModel = Gef.extend(Gef.model.ConnectionModel, {
	type : "transition"
});
//新增的节点模型：中止
Gef.simple.model.EndCancelModel = Gef.extend(Gef.model.NodeModel, {
	type : "endCancel"
});


Gef.ns("Gef.simple.xml");
Gef.simple.xml.SimpleSerializer = Gef.extend(Gef.gef.xml.XmlSerializer, {
	constructor : function($) {
		this.model = $;
		this.map = {
			"start" : Gef.simple.xml.StartWrapper,
			"end" : Gef.simple.xml.EndWrapper,
			"endCancel" : Gef.simple.xml.EndCancelWrapper,
			"task" : Gef.simple.xml.TaskWrapper,
			"state" : Gef.simple.xml.StateWrapper,
			"join" : Gef.simple.xml.JoinWrapper,
			"fork" : Gef.simple.xml.ForkWrapper,
			"decision" : Gef.simple.xml.DecisionWrapper,
			"sign": Gef.simple.xml.CountersignWrapper,
			"sub": Gef.simple.xml.SubprocessWrapper
		}
	},
	appendToBuffer : function($) {
		$.push("<?xml version='1.0' encoding='UTF-8'?>\n");
		$.push("<process");
		if (this.model.text)
			$.push(" name='" + Gef.flowid + "'");
		if (typeof this.model.key == "string" && this.model.key != null
			&& this.model.key != "" && this.model.key.trim().length != 0)
			$.push(" key='" + this.model.key + "'");
		if (typeof this.model.version == "string" && this.model.version != null
			&& this.model.version != "" && this.model.version.trim().length != 0)
			$.push(" version='" + this.model.version + "'");
		$.push(" xmlns='http://jbpm.org/4.4/jpdl'>\n");
		if (typeof this.model.description == "string" && this.model.description != null
			&& this.model.description != "" && this.model.description.trim().length != 0)
			$.push("  <description>" + this.model.description + "</description>\n");
		if (this.model.events)
			Gef.each(this.model.events, function(_) {
				$.push("    <on event=\"", _.name, "\">\n");
				$.push("      <event-listener class=\"", _.classname, "\"/>\n");
				$.push("    </on>\n")
			}, this);
		if (this.model.timers)
			Gef.each(this.model.timers, function(_) {
				$.push("    <timer duedate=\"", _.duedate, "\" repeat=\"", _.repeat, "\" duedatetime=\"", _.duedatetime, "\">\n");
				$.push("      <description>", _.description, "</description>\n");
				$.push("      <event-listener class=\"", _.classname, "\"/>\n");
				$.push("    </timer>\n")
			}, this);
		if (this.model.swimlanes)
			Gef.each(this.model.swimlanes, function(_) {
				$.push("    <swimlane name=\"", _.name, "\" assignee=\"", _.assignee, "\" candidate-users=\"", _.candidateUsers, "\" candidate-groups=\"", _.candidateGroups, "\">\n");
				$.push("      <description>", _.description, "</description>\n");
				$.push("    </swimlane>\n")
			}, this);
		this.appendBody($);
		$.push("</process>")
	}
});
Gef.simple.xml.AbstractNodeWrapper = Gef.extend(Gef.gef.xml.AbstractWrapper, {
	appendAttributes : function(_) {
		var $ = this.node;
		_.push(" name='", $.text, "' g='");
		if ($.type == "start" || $.type == "state" || $.type == "end" || $.type == "cancel"
			|| $.type == "error" || $.type == "decision" || $.type == "fork" || $.type == "join")
			_.push($.x, ",", $.y, ",", $.w, ",", $.h, "'");
		else
			_.push(($.x), ",", ($.y), ",", ($.w), ",", ($.h), "'");
	},
	appendBody : function($) {
		var nodeName = this.node.text;
		var nodeTimerSetting = Gef.Editor.findNodeTimerSettingByNodeName(nodeName);
		if(null != nodeTimerSetting && nodeTimerSetting.actionTimerEnable == true){
			var duedate = nodeTimerSetting.dayDuedate*24*60+nodeTimerSetting.hourDuedate*60+nodeTimerSetting.minuteDuedate;
			var repeat = nodeTimerSetting.dayRepeat*24*60+nodeTimerSetting.hourRepeat*60+nodeTimerSetting.minuteRepeat;
			$.push("    <on event=\"timeout\">\n");
			$.push("        <timer duedate=\""+duedate+" minutes\"");
			if(repeat>0){
				$.push(" repeat='"+repeat+" minutes'");
			}
			$.push(" />\n");
			$.push("        <event-listener class=\""+Gef.NODE_TIMER_LISTENER+"\" />\n");
			$.push("    </on>\n")
		}
		Gef.each(this.node.getSourceConnections(), function(A) {
			$.push("    <transition");
			if (A.text != null && A.text != "")
				$.push(" name='", A.text, "'");
			if (A.innerPoints.length != 0 || A.textX != 0 || A.textY != 0) {
				$.push(" g='");
				Gef.each(A.innerPoints, function(B, _) {
					$.push(parseInt(B[0], 10), ",", parseInt(B[1], 10));
					if (_ != A.innerPoints.length - 1)
						$.push(";")
				});
				var _ = this.getTextPosition(A);
				$.push(_);
				$.push("'")
			}
			if('end'== A.getTarget().type){
				$.push(" to='结束'>\n");
			}else if('endCancel'== A.getTarget().type){
				$.push(" to='中止'>\n");
			}else{
				$.push(" to='", A.getTarget().text, "'>\n");
			}
			if(null != nodeTimerSetting && nodeTimerSetting.clockTimerEnable == true && nodeTimerSetting.transitionName==A.text){
				var clockDuedate = nodeTimerSetting.dayClock*24*60+nodeTimerSetting.hourClock*60+nodeTimerSetting.minuteClock;
				$.push("     <timer duedate=\""+ clockDuedate +" minutes\"/>\n")
			}
			$.push("     <event-listener class=\""+ Gef.EVENT_LISTENER +"\"/>\n");
			$.push("    </transition>\n");
		}, this)
	},
	getTextPosition : function(E) {
		var P = E.getSource(), K = new Geom.Rect(parseInt(P.x, 10), parseInt(
			P.y, 10), parseInt(P.w, 10), parseInt(P.h, 10)), N = E
				.getTarget(), J = new Geom.Rect(parseInt(N.x, 10), parseInt(
			N.y, 10), parseInt(N.w, 10), parseInt(N.h, 10)),
			$ = new Geom.Line(parseInt(K.x, 10) + parseInt(K.w, 10) / 2, parseInt(K.y, 10)
																		 + parseInt(K.h, 10) / 2, parseInt(J.x, 10)
																								  + parseInt(J.w, 10) / 2, parseInt(J.y, 10)
																														   + parseInt(J.h, 10) / 2);
		//这里做过非空判断，这里的算法在计算我们自己的JPDL时，会出现F,C,L，B为null的情况。 JACKY 2010-09-06
		var F = (K.getCrossPoint($) == null ? new Object({x:0, y:0}):K.getCrossPoint($));
		var C = (J.getCrossPoint($) == null ? new Object({x:10, y:10}): J.getCrossPoint($));
		var L = (F == null ? 0 : (F.x + C.x) / 2);
		var B = (F == null ? 0 :(F.y + C.y) / 2);

		if (E.innerPoints.length > 0) {
			var A = E.innerPoints[0], _ = E.innerPoints[E.innerPoints.length
														- 1], O = [];
			O.push([F.x, F.y]);
			Gef.each(E.innerPoints, function($) {
				O.push([$[0], $[1]])
			});
			O.push([C.x, C.y]);
			var H = O.length, G = 0, D = 0;
			if ((H % 2) == 0) {
				var I = O[H / 2 - 1], M = O[H / 2];
				G = (I[0] + M[0]) / 2;
				D = (I[1] + M[1]) / 2
			} else {
				G = O[(H - 1) / 2][0];
				D = O[(H - 1) / 2][1]
			}
			var R = parseInt(E.textX + L - G, 10), Q = parseInt(
				E.textY + B - D, 10);
			return ":" + R + "," + Q
		} else if (E.textX != 0 && E.textY != 0)
			return parseInt(E.textX, 10) + "," + parseInt(E.textY, 10);
		else
			return ""
	}
});
Gef.simple.xml.SimpleDeserializer = Gef.extend(Gef.gef.xml.XmlDeserializer, {
	decode : function() {
		var pmodel = new Gef.simple.model.ProcessModel();
		this.modelMap = {};
		this.domMap = {};
		this.parseRoot(pmodel);
		delete this.modelMap;
		delete this.domMap;
		return pmodel;
	},
	parseRoot : function(processModel) {
		var $ = this.xdoc.documentElement;
		processModel.text = $.getAttribute("name");
		processModel.key = $.getAttribute("key");
		processModel.version = $.getAttribute("version");
		processModel.description = this.getElementContent($, "description");
		this.bindEvents($, processModel);
		this.bindTimers($, processModel);
		this.bindSwimlanes($, processModel);
		Gef.each($.childNodes, function(childNode) {
			this.parseNode(childNode, processModel)
		}, this);
		Gef.each(processModel.getChildren(), function(childNode) {
			this.parseConnections(childNode)
		}, this)
	},
	parseNode : function(node, processModel) {
		var $ = node.nodeName;
		switch (node.nodeName) {
			case "start" :
				this.parseStart(node, processModel);
				break;
			case "end" :
				this.parseEnd(node, processModel);
				break;
			case "end-cancel" :
				this.parseEndCancel(node, processModel);
				break;
			case "task" :
				this.parseTask(node, processModel);
				break;
			case "state" ://新的节点
				this.parseState(node, processModel);
				break;
			case "fork" ://新的节点
				this.parseFork(node, processModel);
				break;
			case "join" ://新的节点
				this.parseJoin(node, processModel);
				break;
			case "decision" ://新的节点
				this.parseDecision(node, processModel);
				break;
			case "sign" ://新增会签节点
				this.parseCountersign(node, processModel);
				break;
			case "sub" ://新增子流程节点
				this.parseSubprocess(node, processModel);
				break;
		}
	},
	parseConnections : function(node) {
		var _ = this.domMap[node.text];
		Gef.each(_.childNodes, function(_) {
			if (_.nodeName == "transition")
				this.parseConnection(_, node)
		}, this)
	},
	parseConnection : function(A, _) {
		var B = new Gef.simple.model.TransitionModel();
		B.text = A.getAttribute("name");
		var $ = A.getAttribute("to"), C = this.modelMap[$];
		B.setSource(_);
		_.addSourceConnection(B);
		B.setTarget(C);
		C.addTargetConnection(B);
		this.bindConnectionLocation(A, B)
	},
	bindConnectionLocation : function(C, $) {
		var _ = C.getAttribute("g");
		if (!_)
			return;
		var E = _, B = _.split(":");
		if (_.indexOf(":") != -1) {
			E = B[1];
			if (B[0].length > 0) {
				var F = B[0].split(";"), D = [];
				Gef.each(F, function($) {
					var _ = $.split(",");
					D.push([parseInt(_[0], 10), parseInt(_[1], 10)])
				});
				$.innerPoints = D
			}
		} else
			E = _;
		var A = E.split(",");
		$.textX = parseInt(A[0], 10);
		$.textY = parseInt(A[1], 10);
		this.calculdateTextPosition($)
	},
	calculdateTextPosition : function(E) {
		var P = E.getSource(), K = new Geom.Rect(parseInt(P.x, 10), parseInt(
			P.y, 10), parseInt(P.w, 10), parseInt(P.h, 10)), N = E
			.getTarget(), J = new Geom.Rect(parseInt(N.x, 10), parseInt(
			N.y, 10), parseInt(N.w, 10), parseInt(N.h, 10)), $ = new Geom.Line(
			parseInt(K.x, 10) + parseInt(K.w, 10) / 2, parseInt(K.y, 10)
													   + parseInt(K.h, 10) / 2, parseInt(J.x, 10)
																				+ parseInt(J.w, 10) / 2, parseInt(J.y, 10)
																										 + parseInt(J.h, 10) / 2);
		//这里做过非空判断，这里的算法在计算我们自己的JPDL时，会出现F,C,L，B为null的情况。 JACKY 2010-09-06
		var F = (K.getCrossPoint($) == null ? new Object({x:0, y:0}):K.getCrossPoint($));
		var C = (J.getCrossPoint($) == null ? new Object({x:10, y:10}): J.getCrossPoint($));
		var L = (F == null ? 0 : (F.x + C.x) / 2);
		var B = (F == null ? 0 :(F.y + C.y) / 2);

		if (E.innerPoints.length > 0) {
			var A = E.innerPoints[0], _ = E.innerPoints[E.innerPoints.length
														- 1], O = [];
			O.push([F.x, F.y]);
			Gef.each(E.innerPoints, function($) {
				O.push([$[0], $[1]])
			});
			O.push([C.x, C.y]);
			var H = O.length, G = 0, D = 0;
			if ((H % 2) == 0) {
				var I = O[H / 2 - 1], M = O[H / 2];
				G = (I[0] + M[0]) / 2;
				D = (I[1] + M[1]) / 2
			} else {
				G = O[(H - 1) / 2][0];
				D = O[(H - 1) / 2][1]
			}
			var R = parseInt(E.textX + L - G, 10), Q = parseInt(
				E.textY + B - D, 10);
			E.textX -= L - G;
			E.textY -= B - D
		}
	},
	bindNodeLocation : function(B, _) {
		var $ = B.getAttribute("g"), A = $.split(",");
		_.x = parseInt(A[0], 10);
		_.y = parseInt(A[1], 10);
		_.w = parseInt(A[2], 10);
		_.h = parseInt(A[3], 10)
	},
	bindEvents : function(_, $) {
		$.events = [];
		Gef.each(_.childNodes, function(_) {
			if (_.nodeName == "on")
				$.events.push({
								  name : _.getAttribute("event"),
								  classname : this.getElementAttribute(_, "event-listener", "class")
							  })
		}, this)
	},
	bindTimers : function(_, $) {
		$.timers = [];
		Gef.each(_.childNodes, function(_) {
			if (_.nodeName == "timer")
				$.timers.push({
								  duedate : _.getAttribute("duedate"),
								  repeat : _.getAttribute("repeat"),
								  duedatetime : _.getAttribute("duedatetime"),
								  description : this.getElementContent(_, "description"),
								  classname : this.getElementContent(_, "event-listener",
																	 "classname")
							  })
		}, this)
	},
	bindSwimlanes : function(_, $) {
		$.swimlanes = [];
		Gef.each(_.childNodes, function(_) {
			if (_.nodeName == "swimlane")
				$.swimlanes.push({
									 name : _.getAttribute("name"),
									 assignee : _.getAttribute("assignee"),
									 candidateUsers : _.getAttribute("candidate-users"),
									 candidateGroups : _.getAttribute("candidate-groups"),
									 description : this.getElementContent(_, "description")
								 })
		}, this)
	},
	getElementContent : function(_, A) {
		var $ = null;
		Gef.each(_.childNodes, function(_) {
			if (_.nodeName == A) {
				$ = _.textContent;
				return false
			}
		});
		return $
	},
	getElementAttribute : function(_, A, B) {
		var $ = null;
		Gef.each(_.childNodes, function(_) {
			if (_.nodeName == A) {
				$ = _.getAttribute(B);
				return false
			}
		});
		return $
	},
	parseStart : function(B, A) {
		var _ = new Gef.simple.model.StartModel(), $ = B.getAttribute("name");
		_.text = $;
		_.form = B.getAttribute("form");
		_.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, _);
		this.bindEvents(B, _);
		this.modelMap[$] = _;
		this.domMap[$] = B;
		A.addChild(_)
	},
	parseEnd : function(B, A) {
		var _ = new Gef.simple.model.EndModel(), $ = B.getAttribute("name");
		_.text = $;
		_.ends = B.getAttribute("ends");
		_.state = B.getAttribute("state");
		_.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, _);
		this.bindEvents(B, _);
		this.modelMap[$] = _;
		this.domMap[$] = B;
		A.addChild(_)
	},
	parseTask : function(B, A) {
		var taskModel = new Gef.simple.model.TaskModel(), $ = B.getAttribute("name");
		taskModel.text = $;
		taskModel.assignee = B.getAttribute("assignee");
		taskModel.candidateUsers = B.getAttribute("candidate-users");
		taskModel.candidateGroups = B.getAttribute("candidate-groups");
		taskModel.swimlane = B.getAttribute("swimlane");
		taskModel.form = B.getAttribute("form");
		taskModel.duedate = B.getAttribute("duedate");
		taskModel.onTransition = B.getAttribute("on-transition");
		taskModel.completion = B.getAttribute("completion");
		taskModel.notification = this.getElementAttribute(B, "notification", "template");
		taskModel.reminder = this.getElementAttribute(B, "reminder", "template");
		taskModel.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, taskModel);
		this.bindEvents(B, taskModel);
		this.bindTimers(B, taskModel);
		this.modelMap[$] = taskModel;
		this.domMap[$] = B;
		A.addChild(taskModel)
	},
	parseState : function(B, A) {
		var _ = new Gef.simple.model.StateModel(), $ = B.getAttribute("name");
		_.text = $;
		_.assignee = B.getAttribute("assignee");
		_.candidateUsers = B.getAttribute("candidate-users");
		_.candidateGroups = B.getAttribute("candidate-groups");
		_.swimlane = B.getAttribute("swimlane");
		_.form = B.getAttribute("form");
		_.duedate = B.getAttribute("duedate");
		_.onTransition = B.getAttribute("on-transition");
		_.completion = B.getAttribute("completion");
		_.notification = this
			.getElementAttribute(B, "notification", "template");
		_.reminder = this.getElementAttribute(B, "reminder", "template");
		_.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, _);
		this.bindEvents(B, _);
		this.bindTimers(B, _);
		this.modelMap[$] = _;
		this.domMap[$] = B;
		A.addChild(_)
	},
	parseJoin : function(B, A) {
		var _ = new Gef.simple.model.JoinModel(), $ = B.getAttribute("name");
		_.text = $;
		_.assignee = B.getAttribute("assignee");
		_.candidateUsers = B.getAttribute("candidate-users");
		_.candidateGroups = B.getAttribute("candidate-groups");
		_.swimlane = B.getAttribute("swimlane");
		_.form = B.getAttribute("form");
		_.duedate = B.getAttribute("duedate");
		_.onTransition = B.getAttribute("on-transition");
		_.completion = B.getAttribute("completion");
		_.notification = this
			.getElementAttribute(B, "notification", "template");
		_.reminder = this.getElementAttribute(B, "reminder", "template");
		_.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, _);
		this.bindEvents(B, _);
		this.bindTimers(B, _);
		this.modelMap[$] = _;
		this.domMap[$] = B;
		A.addChild(_)
	},
	parseFork : function(B, A) {
		var _ = new Gef.simple.model.ForkModel(), $ = B.getAttribute("name");
		_.text = $;
		_.assignee = B.getAttribute("assignee");
		_.candidateUsers = B.getAttribute("candidate-users");
		_.dateGroups = B.getAttribute("candidate-groups");
		_.swimlane = B.getAttribute("swimlane");
		_.form = B.getAttribute("form");
		_.duedate = B.getAttribute("duedate");
		_.onTransition = B.getAttribute("on-transition");
		_.completion = B.getAttribute("completion");
		_.notification = this
			.getElementAttribute(B, "notification", "template");
		_.reminder = this.getElementAttribute(B, "reminder", "template");
		_.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, _);
		this.bindEvents(B, _);
		this.bindTimers(B, _);
		this.modelMap[$] = _;
		this.domMap[$] = B;
		A.addChild(_);
	},
	parseEndCancel : function(B, A) {
		var _ = new Gef.simple.model.EndCancelModel(), $ = B.getAttribute("name");
		_.text = $;
		_.ends = B.getAttribute("ends");
		_.state = B.getAttribute("state");
		_.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, _);
		this.bindEvents(B, _);
		this.modelMap[$] = _;
		this.domMap[$] = B;
		A.addChild(_)
	},
	parseDecision : function(B, A) {
		var _ = new Gef.simple.model.DecisionModel(), $ = B.getAttribute("name");
		_.text = $;
		_.rotate = (B.getAttribute("rotate") == "undefined" || B.getAttribute("rotate") == null || B.getAttribute("rotate") == undefined ? 0 : B.getAttribute("rotate")) ;
		_.assignee = B.getAttribute("assignee");
		_.candidateUsers = B.getAttribute("candidate-users");
		_.candidateGroups = B.getAttribute("candidate-groups");
		_.swimlane = B.getAttribute("swimlane");
		_.form = B.getAttribute("form");
		_.duedate = B.getAttribute("duedate");
		_.onTransition = B.getAttribute("on-transition");
		_.completion = B.getAttribute("completion");
		_.notification = this.getElementAttribute(B, "notification", "template");
		_.reminder = this.getElementAttribute(B, "reminder", "template");
		_.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, _);
		this.bindEvents(B, _);
		this.bindTimers(B, _);
		this.modelMap[$] = _;
		this.domMap[$] = B;
		A.addChild(_)
	},
	parseCountersign : function(B, A) {
		var _ = new Gef.simple.model.CountersignModel(), $ = B.getAttribute("name");
		_.text = $;
		_.assignee = B.getAttribute("assignee");
		_.candidateUsers = B.getAttribute("candidate-users");
		_.candidateGroups = B.getAttribute("candidate-groups");
		_.swimlane = B.getAttribute("swimlane");
		_.form = B.getAttribute("form");
		_.duedate = B.getAttribute("duedate");
		_.onTransition = B.getAttribute("on-transition");
		_.completion = B.getAttribute("completion");
		_.notification = this
			.getElementAttribute(B, "notification", "template");
		_.reminder = this.getElementAttribute(B, "reminder", "template");
		_.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, _);
		this.bindEvents(B, _);
		this.bindTimers(B, _);
		this.modelMap[$] = _;
		this.domMap[$] = B;
		A.addChild(_)
	},
	parseSubprocess : function(B, A) {
		var _ = new Gef.simple.model.SubprocessModel(), $ = B.getAttribute("name");
		_.text = $;
		_.assignee = B.getAttribute("assignee");
		_.candidateUsers = B.getAttribute("candidate-users");
		_.candidateGroups = B.getAttribute("candidate-groups");
		_.swimlane = B.getAttribute("swimlane");
		_.form = B.getAttribute("form");
		_.duedate = B.getAttribute("duedate");
		_.onTransition = B.getAttribute("on-transition");
		_.completion = B.getAttribute("completion");
		_.notification = this.getElementAttribute(B, "notification", "template");
		_.reminder = this.getElementAttribute(B, "reminder", "template");
		_.description = this.getElementContent(B, "description");
		this.bindNodeLocation(B, _);
		this.bindEvents(B, _);
		this.bindTimers(B, _);
		this.modelMap[$] = _;
		this.domMap[$] = B;
		A.addChild(_)
	}

});
Gef.simple.xml.StartWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.StartWrapper.superclass.appendAttributes.call(this, _);
		var $ = this.node;
		if (typeof $.form == "string" && $.form.trim().length != 0)
			_.push(" form=\"" + $.form + "\"")
	}
});
Gef.simple.xml.EndWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.EndWrapper.superclass.appendAttributes.call(this, _);
		var $ = this.node;
		if (typeof $.ends == "string" && $.ends.trim().length != 0)
			_.push(" ends=\"" + $.ends + "\"");
		if (typeof $.state == "string" && $.state.trim().length != 0)
			_.push(" state=\"" + $.state + "\"")
	}
});
Gef.simple.xml.EndCancelWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.EndCancelWrapper.superclass.appendAttributes.call(this, _);
		var $ = this.node;
		if (typeof $.ends == "string" && $.ends.trim().length != 0)
			_.push(" ends=\"" + $.ends + "\"");
		if (typeof $.state == "string" && $.state.trim().length != 0)
			_.push(" state=\"" + $.state + "\"")
	}
});
Gef.simple.xml.TaskWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendAttributes.call(this, _);
		var $ = this.node;
		var nodeName = $.text;
		var nodeSetting = Gef.Editor.findTaskNodeSettingByNodeName(nodeName);
		var groupName = 'all_maintainance';
		var taskNodePermission;
		if(null != nodeSetting){
			var taskType = nodeSetting.taskType;
			var assignType = nodeSetting.assignType;
			var has_candidate_groups = false; //是否已经添加了candidate-groups，属性重复会导致发布失败
			if(1==assignType || 3==assignType){//主动认领的分配方式，或者是手工分配和主动认领皆可
				taskNodePermission = Gef.Editor.findTaskNodePermissionByNodeName(nodeName);
				if(null != taskNodePermission){
					groupName = Gef.flowid+"_"+nodeName;
				}
				_.push(" candidate-groups=\"" + groupName + "\"");
				has_candidate_groups = true;
			}
			/** 针对固有4大流程在重新发布中，节点既是多人协作，又是主动认领的特殊处理，
			 */
			// if("INC"==jQuery("#processKey_hidden").val() || "RFC"==jQuery("#processKey_hidden").val()){
			// 	if(!has_candidate_groups && (("待分配"==nodeName && taskType==1) || ("被拒绝"==nodeName && taskType==0) || ("已批准"==nodeName && taskType==0))){
			// 		taskNodePermission = Gef.Editor.findTaskNodePermissionByNodeName(nodeName);
			// 		if(null != taskNodePermission){
			// 			groupName= jQuery("#processKey_hidden").val()+"_"+nodeName;
			// 		}
			// 		_.push(" candidate-groups=\"" + groupName + "\"");
			// 	}
			// }
		}else{//默认为主动认领分配方式
			taskNodePermission = Gef.Editor.findTaskNodePermissionByNodeName(nodeName);
			if(null != taskNodePermission){
				groupName = Gef.flowid+"_"+nodeName;
			}
			_.push(" candidate-groups=\"" + groupName + "\"");
		}
	},
	appendBody : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendBody.call(this, _);
		var $ = this.node;
		var nodeName = $.text;
		var nodeSetting = Gef.Editor.findTaskNodeSettingByNodeName(nodeName);
		if(null != nodeSetting){
			var taskType = nodeSetting.taskType;
			var assignType = nodeSetting.assignType;
			if(1==taskType){//多人协作任务
				_.push("    <assignment-handler class=\""+ Gef.FIXED_ASSIGN_HANDLER +"\"/>\n");
			}
			if(0==taskType && 1!=assignType){//独立完成的任务,且分配方式不为主动认领
				var assignClass = Gef.RANDOM_ASSIGN_HANDLER;
				if(0==assignType || 3==assignType){//手工分配,或者是手工分配和主动认领皆可
					assignClass = Gef.FIXED_ASSIGN_HANDLER;
				}
				_.push("    <assignment-handler class=\""+ assignClass +"\"/>\n");
			}
		}
		//为每个Task节点增加一个任务开始和结束监听器
		_.push("    <on event=\"start\">\n");
		_.push("        <event-listener class=\""+ Gef.TASK_ENTER_HANDLER +"\"/>\n");
		_.push("    </on>\n");
		_.push("    <on event=\"end\">\n");
		_.push("        <event-listener class=\""+ Gef.TASK_LEAVE_HANDLER +"\"/>\n");
		_.push("    </on>\n");
	}
});
Gef.simple.xml.StateWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.StateWrapper.superclass.appendAttributes.call(this, _);
		var $ = this.node;
		if (typeof $.assignee == "string" && $.assignee.trim().length != 0)
			_.push(" assignee=\"" + $.assignee + "\"");
		if (typeof $.candidateUsers == "string"
			&& $.candidateUsers.trim().length != 0)
			_.push(" candidate-users=\"" + $.candidateUsers + "\"");
		if (typeof $.candidateGroups == "string"
			&& $.candidateGroups.trim().length != 0)
			_.push(" candidate-groups=\"" + $.candidateGroups + "\"");
		if (typeof $.swimlane == "string" && $.swimlane.trim().length != 0)
			_.push(" swimlane=\"" + $.swimlane + "\"");
//		if (typeof $.form == "string" && $.form.trim().length != 0)
//			_.push(" form=\"" + $.form + "\"");
		if (typeof $.duedate == "string" && $.duedate.trim().length != 0)
			_.push(" duedate=\"" + $.duedate + "\"");
		if (typeof $.onTransition == "string"
			&& $.onTransition.trim().length != 0)
			_.push(" on-transition=\"" + $.onTransition + "\"");
		if (typeof $.completion == "string" && $.completion.trim().length != 0)
			_.push(" completion=\"" + $.completion + "\"")
	},
	appendBody : function(_) {
		Gef.simple.xml.StateWrapper.superclass.appendBody.call(this, _);
		var $ = this.node;
		if (typeof $.notification == "string"
			&& $.notification.trim().length != 0)
			_.push("    <notification template=\"" + $.notification + "\"/>\n");
		if (typeof $.reminder == "string" && $.reminder.trim().length != 0)
			_.push("    <reminder template=\"" + $.reminder + "\"/>\n")
	}
});
//新增会签节点
Gef.simple.xml.CountersignWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendAttributes.call(this, _);
		var $ = this.node;
		var nodeName = $.text;
		var groupName = Gef.flowid+"_"+nodeName;
		_.push(" candidate-groups=\"" + groupName + "\"");
	},
	appendBody : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendBody.call(this, _);
		var $ = this.node;
		//为每个会签节点增加一个任务开始和结束监听器
		_.push("    <on event=\"start\">\n");
		_.push("        <event-listener class=\""+ Gef.SIGN_ENTER_HANDLER +"\"/>\n");
		_.push("    </on>\n");
		_.push("    <on event=\"end\">\n");
		_.push("        <event-listener class=\""+ Gef.SIGN_LEAVE_HANDLER +"\"/>\n");
		_.push("    </on>\n");
	}
});
//新增子流程节点
Gef.simple.xml.SubprocessWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendAttributes.call(this, _);
		var $ = this.node;
		var nodeName = $.text;
		var taskNodePermission = Gef.Editor.findTaskNodePermissionByNodeName(nodeName);
		var groupName = "all_maintainance"
		if(null != taskNodePermission){
			groupName = Gef.flowid+"_"+nodeName;
		}
		_.push(" candidate-groups=\"" + groupName + "\"");
	},
	appendBody : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendBody.call(this, _);
		var $ = this.node;
		//为每个子流程节点增加一个任务开始和结束监听器
		_.push("    <on event=\"start\">\n");
		_.push("        <event-listener class=\""+ Gef.SUB_TASK_ENTER_HANDLER +"\"/>\n");
		_.push("    </on>\n");
		_.push("    <on event=\"end\">\n");
		_.push("        <event-listener class=\""+ Gef.SUB_TASK_LEAVE_HANDLER +"\"/>\n");
		_.push("    </on>\n");
	}
});
Gef.simple.xml.JoinWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendAttributes.call(this, _);
		var $ = this.node;
		var nodeName = $.text;
		Gef.Event.trigger(Gef.Event.GetProcessParameterByNames,nodeName,'multiplicity',function(processParameter){
			if(processParameter != null){
				_.push(" multiplicity=\"" + processParameter.parameterValue + "\"");
			}
		});
	},
	appendBody : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendBody.call(this, _);
		//为每个JOIN节点增加进入事件监听器
		_.push("    <on event=\"start\">\n");
		_.push("        <event-listener class=\""+ Gef.JOIN_ENTER_HANDLER +"\"/>\n");
		_.push("    </on>\n");
	}
});
Gef.simple.xml.ForkWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendAttributes.call(this, _);
	},
	appendBody : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendBody.call(this, _);
	}
});
Gef.simple.xml.DecisionWrapper = Gef.extend(Gef.simple.xml.AbstractNodeWrapper, {
	appendAttributes : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendAttributes.call(this, _);
		_.push(" rotate='",this.node.rotate,"'")
	},
	appendBody : function(_) {
		Gef.simple.xml.TaskWrapper.superclass.appendBody.call(this, _);
		// var $ = this.node;
		_.push("    <handler class=\""+ Gef.DECISION_HANDLER +"\"/>\n")
	}
});
